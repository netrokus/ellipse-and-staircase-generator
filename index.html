<!DOCTYPE HTML>
<html>
<head>
<title>Ellipse and Staircase Generator</title>
<link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">

<style>
* {
  box-sizing: border-box;
}

/* ==================== THEME VARIABLES ==================== */
:root {
  --primary: #1565c0;
  --primary-hover: #1976d2;
  --primary-light: #bbdefb;
  --on-primary: #ffffff;
  --surface: #ffffff;
  --surface-variant: #f5f5f5;
  --on-surface: #1d1b20;
  --on-surface-variant: #49454f;
  --outline: #79747e;
  --outline-variant: #cac4d0;
  --background: #fefbff;
  --on-background: #1d1b20;
  --selection-bg: #e3f2fd;
  --grid-color: #e7e0ec;
  --canvas-bg: #fefbff;
  --canvas-surface: #ffffff;
  --ellipse-outer: #d32f2f;
  --ellipse-inner: #1565c0;
  --block-color: #1d1b20;
  --instruction-bg: #fff8e1;
  --instruction-border: #f9cc33;
  --instruction-text: #614a00;
  --shadow: rgba(0, 0, 0, 0.12);
  --shadow-strong: rgba(0, 0, 0, 0.16);
}

[data-theme="dark"] {
  --primary: #90caf9;
  --primary-hover: #64b5f6;
  --primary-light: #1e3a8a;
  --on-primary: #003d82;
  --surface: #1d1b20;
  --surface-variant: #141218;
  --on-surface: #e6e0e9;
  --on-surface-variant: #cac4d0;
  --outline: #938f99;
  --outline-variant: #49454f;
  --background: #141218;
  --on-background: #e6e0e9;
  --selection-bg: #2b2930;
  --grid-color: #49454f;
  --canvas-bg: #141218;
  --canvas-surface: #1d1b20;
  --ellipse-outer: #f2b8b5;
  --ellipse-inner: #a8c7fa;
  --block-color: #e6e0e9;
  --instruction-bg: #3d2f00;
  --instruction-border: #6c5d00;
  --instruction-text: #ffd95a;
  --shadow: rgba(0, 0, 0, 0.3);
  --shadow-strong: rgba(0, 0, 0, 0.4);
}

/* ==================== BASE LAYOUT ==================== */
html, body {
  margin: 0;
  padding: 0;
  font-family: 'Roboto', -apple-system, BlinkMacSystemFont, sans-serif;
  background-color: var(--background);
  color: var(--on-background);
  transition: background-color 0.3s ease, color 0.3s ease;
}

body {
  height: 100vh;
  display: flex;
  flex-direction: column;
}

/* ==================== TOP BAR ==================== */
.top-app-bar {
  background: var(--primary);
  color: var(--on-primary);
  padding: 16px 24px;
  elevation: 2;
  box-shadow: 0px 2px 4px var(--shadow);
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.top-app-bar h1 {
  margin: 0;
  font-size: 22px;
  font-weight: 400;
}

.header-controls {
  display: flex;
  gap: 8px;
  align-items: center;
}

.theme-toggle, .view-toggle {
  background: none;
  border: none;
  color: var(--on-primary);
  cursor: pointer;
  padding: 8px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: background-color 0.2s ease;
}

.theme-toggle:hover {
  background: rgba(255, 255, 255, 0.1);
}

.view-toggle {
  border-radius: 20px;
  padding: 8px 16px;
  gap: 8px;
  background: rgba(255, 255, 255, 0.1);
  border: 1px solid rgba(255, 255, 255, 0.2);
  font-size: 14px;
  font-weight: 500;
}

.view-toggle:hover {
  background: rgba(255, 255, 255, 0.2);
}

.view-toggle.active {
  background: var(--on-primary);
  color: var(--primary);
}

.material-icons {
  font-size: 24px;
}

/* ==================== CONTENT AREA ==================== */
.content {
  flex: 1;
  display: flex;
  gap: 16px;
  padding: 16px;
  overflow: hidden;
}

.controls-panel {
  width: 320px;
  display: flex;
  flex-direction: column;
  gap: 16px;
  overflow-y: auto;
  overflow-x: hidden;
  padding-right: 8px;
}

.controls-panel::-webkit-scrollbar {
  width: 8px;
}

.controls-panel::-webkit-scrollbar-track {
  background: var(--surface-variant);
  border-radius: 4px;
}

.controls-panel::-webkit-scrollbar-thumb {
  background: var(--outline);
  border-radius: 4px;
}

.controls-panel::-webkit-scrollbar-thumb:hover {
  background: var(--outline-variant);
}

/* ==================== SURFACE CARDS ==================== */
.surface {
  background: var(--surface);
  border-radius: 12px;
  padding: 16px;
  box-shadow: 0px 1px 3px var(--shadow);
  border: 1px solid var(--outline-variant);
  transition: background-color 0.3s ease, border-color 0.3s ease;
}

.surface h2 {
  margin: 0 0 16px 0;
  font-size: 16px;
  font-weight: 500;
  color: var(--primary);
}

/* ==================== CONTROLS ==================== */
.control-group {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 12px;
}

.control-group:last-child {
  margin-bottom: 0;
}

.label {
  font-size: 12px;
  color: var(--on-surface-variant);
  font-weight: 500;
  min-width: 60px;
}

.input-field {
  width: 80px;
  height: 40px;
  border: 1px solid var(--outline);
  border-radius: 4px;
  padding: 0 12px;
  font-family: inherit;
  font-size: 14px;
  text-align: center;
  background: var(--surface);
  color: var(--on-surface);
  transition: border-color 0.2s ease, background-color 0.3s ease, color 0.3s ease;
}

.input-field:focus {
  outline: none;
  border-color: var(--primary);
  border-width: 2px;
}

/* ==================== BUTTONS ==================== */
.btn {
  border: none;
  border-radius: 20px;
  padding: 8px 16px;
  font-family: inherit;
  font-weight: 500;
  font-size: 14px;
  cursor: pointer;
  transition: all 0.2s ease;
  min-width: 40px;
  height: 40px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.btn-filled {
  background: var(--primary);
  color: var(--on-primary);
}

.btn-filled:hover {
  background: var(--primary-hover);
  box-shadow: 0px 1px 3px var(--shadow-strong);
}

.btn-outlined {
  background: transparent;
  border: 1px solid var(--outline);
  color: var(--primary);
  gap: 4px;
  padding: 10px 16px;
}

.btn-outlined:hover {
  background: var(--primary-light);
  border-color: var(--primary);
}

.btn-outlined:active {
  background: var(--selection-bg);
}

.btn-mirror {
  background: transparent;
  border: 1px solid var(--outline);
  color: var(--on-surface-variant);
  min-width: 40px;
  transition: all 0.2s ease;
}

.btn-mirror.mirrored {
  background: var(--primary);
  color: var(--on-primary);
  border-color: var(--primary);
  box-shadow: 0px 1px 3px var(--shadow);
}

.btn-mirror:hover {
  background: var(--selection-bg);
}

.btn-mirror.mirrored:hover {
  background: var(--primary-hover);
}

/* ==================== SPECIALIZED CONTROLS ==================== */
.spoke-controls {
  display: flex;
  gap: 8px;
  width: 100%;
}

.spoke-controls .btn-outlined {
  flex: 1;
}

.direction-toggle {
  display: flex;
  gap: 4px;
  padding: 4px;
  background: var(--surface-variant);
  border-radius: 8px;
}

.direction-btn {
  flex: 1;
  padding: 8px 12px;
  border: none;
  border-radius: 4px;
  background: transparent;
  color: var(--on-surface-variant);
  cursor: pointer;
  transition: all 0.2s ease;
  font-size: 12px;
  font-weight: 500;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 4px;
}

.direction-btn.active {
  background: var(--primary);
  color: var(--on-primary);
  box-shadow: 0px 1px 2px var(--shadow);
}

.direction-btn:hover:not(.active) {
  background: var(--selection-bg);
}

.select {
  position: relative;
  width: 140px;
}

.select select {
  width: 100%;
  height: 40px;
  border: 1px solid var(--outline);
  border-radius: 4px;
  padding: 0 32px 0 12px;
  font-family: inherit;
  font-size: 14px;
  background: var(--surface);
  color: var(--on-surface);
  cursor: pointer;
  appearance: none;
  transition: border-color 0.2s ease, background-color 0.3s ease, color 0.3s ease;
}

.select::after {
  content: 'expand_more';
  font-family: 'Material Icons';
  position: absolute;
  right: 8px;
  top: 50%;
  transform: translateY(-50%);
  pointer-events: none;
  color: var(--on-surface-variant);
}

.select select:focus {
  outline: none;
  border-color: var(--primary);
  border-width: 2px;
}

/* ==================== CANVAS ==================== */
.canvas-container {
  flex: 1;
  background: var(--canvas-surface);
  border-radius: 12px;
  box-shadow: 0px 1px 3px var(--shadow);
  border: 1px solid var(--outline-variant);
  overflow: hidden;
  position: relative;
  transition: background-color 0.3s ease, border-color 0.3s ease;
}

#myCanvas, #scene3d {
  display: block;
  width: 100%;
  height: 100%;
}

#scene3d {
  display: none;
}

/* ==================== INSTRUCTIONS ==================== */
.instructions {
  background: var(--instruction-bg);
  border: 1px solid var(--instruction-border);
  border-radius: 8px;
  padding: 12px;
  font-size: 13px;
  color: var(--instruction-text);
  transition: background-color 0.3s ease, border-color 0.3s ease, color 0.3s ease;
}

.instruction-row {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 4px;
}

.instruction-row:last-child {
  margin-bottom: 0;
}

.instruction-row .material-icons {
  font-size: 16px;
}
</style>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
// ==================== CONSTANTS ====================
const CONSTANTS = {
  BLOCK_SIZE: 0.5,
  MIN_ELLIPSE_SIZE: 3,
  MIN_INNER_SIZE: 1,
  MIN_SPOKES: 4,
  MAX_SPOKES: 64,
  MIN_STEP_HEIGHT: 0.5,
  MAX_STEP_HEIGHT: 5,
  MIN_ROTATIONS: 0.5,
  MAX_ROTATIONS: 5,
  CAMERA_MOVE_SPEED: 0.2,
  OPACITY: {
    OUTER_RING: 0.1,
    INNER_RING: 0.3,
    ELLIPSE_OUTLINE: 0.3,
    EDGE: 0.5
  }
};

// ==================== STATE MANAGEMENT ====================
const state = {
  ellipse: {
    width: 40,
    height: 40,
    innerWidth: 20,
    innerHeight: 20,
    outerMirrored: true,
    innerMirrored: true
  },
  canvas: {
    width: 100,
    height: 100,
    scale: [0, 0, 1, 1],
    selection: [-1, -1, -1, -1],
    makingSelection: false,
    panning: false,
    panData: [0, 0, 0, 0],
    fitMode: 0
  },
  spokes: {
    current: 0,
    total: 32,
    fillSteps: true
  },
  view3D: {
    enabled: false,
    direction: 1,
    stepHeight: 1,
    startingSpoke: 0,
    rotations: 1,
    showSingleStep: false,
    scene: null,
    camera: null,
    renderer: null,
    cameraTarget: null,
    keys: {},
    needsRender: false
  }
};

// ==================== UTILITY FUNCTIONS ====================
const utils = {
  isDarkTheme() {
    return document.documentElement.getAttribute('data-theme') === 'dark';
  },

  normalizeAngle(angle) {
    return angle < 0 ? angle + 2 * Math.PI : angle;
  },

  clamp(value, min, max) {
    return Math.max(min, Math.min(max, value));
  },

  make2dArray(length) {
    return Array.from({ length }, () => []);
  },

  inside(x, y, cx, cy, rx, ry) {
    if (rx <= 0 || ry <= 0) return false;
    const ny = (y - cy) / ry;
    const nx = (x - cx) / rx;
    return (nx * nx + ny * ny < 1);
  },

  through(x, y, cx, cy, rx, ry) {
    let count = 0;
    count += utils.inside(x - 0.5, y - 0.5, cx, cy, rx, ry);
    count += utils.inside(x + 0.5, y - 0.5, cx, cy, rx, ry);
    count += utils.inside(x - 0.5, y + 0.5, cx, cy, rx, ry);
    count += utils.inside(x + 0.5, y + 0.5, cx, cy, rx, ry);
    return (count !== 0) && (count !== 4);
  },

  between(x, a, b) {
    return (x >= a && x <= b) || (x >= b && x <= a);
  },

  plotLine(x0, y0, x1, y1, grid) {
    const dx = x1 - x0;
    const dy = y1 - y0;
    const steps = Math.max(Math.abs(dx), Math.abs(dy));
    
    if (steps === 0) {
      const gridX = Math.round(x0);
      const gridY = Math.round(y0);
      if (grid[gridY]) grid[gridY][gridX] = true;
      return;
    }

    const xIncrement = dx / steps;
    const yIncrement = dy / steps;
    let x = x0;
    let y = y0;

    for (let i = 0; i <= steps; i++) {
      const gridX = Math.round(x);
      const gridY = Math.round(y);
      if (grid[gridY] && gridX >= 0 && gridX < grid[gridY].length && gridY >= 0) {
        grid[gridY][gridX] = true;
      }
      x += xIncrement;
      y += yIncrement;
    }
  },

  fillWedgeBetweenSpokes(array, spokeIndex, cx, cy, inner_rx, inner_ry, rx, ry, totalSpokes) {
    const ew = array[0].length;
    const eh = array.length;
    const currentAngle = (spokeIndex / totalSpokes) * 2 * Math.PI;
    const nextAngle = ((spokeIndex + 1) / totalSpokes) * 2 * Math.PI;
    
    for (let j = 0; j < eh; j++) {
      for (let i = 0; i < ew; i++) {
        const dx = i - cx;
        const dy = j - cy;
        const blockAngle = Math.atan2(dy, dx);
        
        const normBlockAngle = utils.normalizeAngle(blockAngle);
        const normCurrentAngle = utils.normalizeAngle(currentAngle);
        const normNextAngle = utils.normalizeAngle(nextAngle);
        
        let inWedge = false;
        if (normNextAngle > normCurrentAngle) {
          inWedge = normBlockAngle >= normCurrentAngle && normBlockAngle <= normNextAngle;
        } else {
          inWedge = normBlockAngle >= normCurrentAngle || normBlockAngle <= normNextAngle;
        }
        
        const inRing = !utils.inside(i, j, cx, cy, inner_rx, inner_ry) && 
                       utils.inside(i, j, cx, cy, rx, ry);
        
        if (inWedge && inRing) {
          array[j][i] = true;
        }
      }
    }
  }
};

// ==================== 2D RENDERING ====================
const render2D = {
  paintGrid(ctx) {
    ctx.beginPath();
    ctx.strokeStyle = getComputedStyle(document.documentElement)
      .getPropertyValue('--grid-color').trim();
    ctx.lineWidth = 1;
    
    const { width, height } = state.ellipse;
    const { width: canWidth, height: canHeight, scale } = state.canvas;
    
    for (let i = 0; i <= width; i++) {
      let x = (i * canWidth) / width;
      if (x >= canWidth) x = canWidth - 1;
      ctx.moveTo(x + 0.5 + scale[0], scale[1]);
      ctx.lineTo(x + 0.5 + scale[0], canHeight + scale[1]);
    }
    
    for (let i = 0; i <= height; i++) {
      let y = (i * canHeight) / height;
      if (y >= canHeight) y = canHeight - 1;
      ctx.moveTo(scale[0], y + 0.5 + scale[1]);
      ctx.lineTo(canWidth + scale[0], y + 0.5 + scale[1]);
    }
    
    ctx.stroke();
  },

  drawBlock(ctx, x, y, isFilled = true) {
    const { width, height } = state.ellipse;
    const { width: canWidth, height: canHeight, scale } = state.canvas;
    
    const x1 = (x * canWidth) / width;
    const y1 = (y * canHeight) / height;
    const x2 = ((x + 1) * canWidth) / width;
    const y2 = ((y + 1) * canHeight) / height;
    const w = x2 - x1 + 0.75;
    const h = y2 - y1 + 0.75;
    
    ctx.fillRect(x1 + scale[0], y1 + scale[1], w, h);
  },

  getEllipseData() {
    const { width: ew, height: eh, innerWidth: inner_ew, innerHeight: inner_eh } = state.ellipse;
    const arr_final = utils.make2dArray(eh);
    
    for (let j = 0; j < eh; j++) {
      for (let i = 0; i < ew; i++) {
        arr_final[j][i] = false;
      }
    }

    const cx = ew / 2.0 - 0.5;
    const cy = eh / 2.0 - 0.5;
    const rx = ew / 2.0;
    const ry = eh / 2.0;
    const inner_rx = inner_ew / 2.0;
    const inner_ry = inner_eh / 2.0;
    
    // Draw outer and inner ellipse rings
    for (let j = 0; j < eh; j++) {
      for (let i = 0; i < ew; i++) {
        if (utils.through(i, j, cx, cy, rx, ry)) {
          arr_final[j][i] = true;
        }
        if (utils.through(i, j, cx, cy, inner_rx, inner_ry)) {
          arr_final[j][i] = true;
        }
      }
    }
    
    // Add current spoke (only in 2D mode)
    if (!state.view3D.enabled) {
      let { current, total, fillSteps } = state.spokes;
      if (current >= total) current = 0;
      if (current < 0) current = total - 1;
      state.spokes.current = current;

      const arr_spokes = utils.make2dArray(eh);
      const arr_hole = utils.make2dArray(eh);
      
      for (let j = 0; j < eh; j++) {
        for (let i = 0; i < ew; i++) {
          arr_spokes[j][i] = false;
          arr_hole[j][i] = false;
        }
      }

      if (fillSteps) {
        utils.fillWedgeBetweenSpokes(arr_spokes, current, cx, cy, inner_rx, inner_ry, rx, ry, total);
      } else {
        const angle = (current / total) * 2 * Math.PI;
        const endX = cx + rx * Math.cos(angle);
        const endY = cy + ry * Math.sin(angle);
        utils.plotLine(cx, cy, endX, endY, arr_spokes);
      }

      // Mark inner hole
      for (let j = 0; j < eh; j++) {
        for (let i = 0; i < ew; i++) {
          if (utils.inside(i, j, cx, cy, inner_rx, inner_ry)) {
            arr_hole[j][i] = true;
          }
        }
      }

      // Add spoke blocks
      for (let j = 0; j < eh; j++) {
        for (let i = 0; i < ew; i++) {
          if (arr_spokes[j] && arr_spokes[j][i] && !(arr_hole[j] && arr_hole[j][i])) {
            arr_final[j][i] = true;
          }
        }
      }
    }

    return {
      data: arr_final,
      width: ew,
      height: eh,
      centerX: cx,
      centerY: cy,
      radiusX: rx,
      radiusY: ry,
      innerRadiusX: inner_rx,
      innerRadiusY: inner_ry
    };
  },

  draw(ctx) {
    const ellipseData = this.getEllipseData();
    const { data: arr_final, width: ew, height: eh } = ellipseData;
    const rootStyles = getComputedStyle(document.documentElement);
    
    const colors = {
      canvasBg: rootStyles.getPropertyValue('--canvas-bg').trim(),
      selectionBg: rootStyles.getPropertyValue('--selection-bg').trim(),
      blockColor: rootStyles.getPropertyValue('--block-color').trim(),
      ellipseOuter: rootStyles.getPropertyValue('--ellipse-outer').trim(),
      ellipseInner: rootStyles.getPropertyValue('--ellipse-inner').trim()
    };

    const { width: canWidth, height: canHeight, scale, selection } = state.canvas;
    const { width, height } = state.ellipse;

    // Clear canvas
    ctx.fillStyle = colors.canvasBg;
    ctx.fillRect(scale[0], scale[1], canWidth, canHeight);

    // Draw selection
    ctx.fillStyle = colors.selectionBg;
    for (let j = 0; j < height; j++) {
      for (let i = 0; i < width; i++) {
        if (utils.between(i, selection[0], selection[2]) && 
            utils.between(j, selection[1], selection[3])) {
          this.drawBlock(ctx, i, j);
        }
      }
    }
    
    // Draw blocks
    ctx.fillStyle = colors.blockColor;
    for (let j = 0; j < eh; j++) {
      for (let i = 0; i < ew; i++) {
        if (arr_final[j] && arr_final[j][i]) {
          this.drawBlock(ctx, i, j);
        }
      }
    }
    
    // Draw ellipse outlines
    const scaleX = canWidth / ew;
    const scaleY = canHeight / eh;
    
    ctx.beginPath();
    ctx.strokeStyle = colors.ellipseOuter;
    ctx.lineWidth = 2;
    ctx.ellipse(
      (ellipseData.centerX + 0.5) * scaleX + scale[0],
      (ellipseData.centerY + 0.5) * scaleY + scale[1],
      ellipseData.radiusX * scaleX,
      ellipseData.radiusY * scaleY,
      0, 0, 2 * Math.PI
    );
    ctx.stroke();

    ctx.beginPath();
    ctx.strokeStyle = colors.ellipseInner;
    ctx.lineWidth = 2;
    ctx.ellipse(
      (ellipseData.centerX + 0.5) * scaleX + scale[0],
      (ellipseData.centerY + 0.5) * scaleY + scale[1],
      ellipseData.innerRadiusX * scaleX,
      ellipseData.innerRadiusY * scaleY,
      0, 0, 2 * Math.PI
    );
    ctx.stroke();

    this.paintGrid(ctx);
  }
};

// ==================== 3D RENDERING ====================
const render3D = {
  init() {
    try {
      const container = document.getElementById('scene3d');
      const rect = container.getBoundingClientRect();
      
      state.view3D.scene = new THREE.Scene();
      state.view3D.scene.background = new THREE.Color(utils.isDarkTheme() ? 0x141218 : 0xfefbff);
      
      state.view3D.camera = new THREE.PerspectiveCamera(75, rect.width / rect.height, 0.1, 1000);
      state.view3D.camera.position.set(20, 15, 20);
      
      state.view3D.cameraTarget = new THREE.Vector3(0, 0, 0);
      state.view3D.camera.lookAt(state.view3D.cameraTarget);
      
      state.view3D.renderer = new THREE.WebGLRenderer({ antialias: true });
      state.view3D.renderer.setSize(rect.width, rect.height);
      state.view3D.renderer.shadowMap.enabled = true;
      state.view3D.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      
      container.appendChild(state.view3D.renderer.domElement);
      
      this.setupLighting();
      this.setupControls(container);
      this.startAnimationLoop();
      this.generateStaircase();
    } catch (error) {
      console.error('Failed to initialize 3D mode:', error);
      alert('3D visualization failed to initialize. Your browser may not support WebGL.');
      toggleViewMode(); // Fall back to 2D
    }
  },

  setupLighting() {
    const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
    state.view3D.scene.add(ambientLight);
    
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(50, 50, 25);
    directionalLight.castShadow = true;
    directionalLight.shadow.mapSize.width = 2048;
    directionalLight.shadow.mapSize.height = 2048;
    state.view3D.scene.add(directionalLight);
  },

  setupControls(container) {
    let mouseDown = false;
    let mouseX = 0;
    let mouseY = 0;
    
    container.addEventListener('mousedown', (e) => {
      mouseDown = true;
      mouseX = e.clientX;
      mouseY = e.clientY;
      container.focus();
    });
    
    container.addEventListener('mousemove', (e) => {
      if (!mouseDown) return;
      
      const deltaX = e.clientX - mouseX;
      const deltaY = e.clientY - mouseY;
      const { camera, cameraTarget } = state.view3D;
      
      if (e.shiftKey) {
        // Pan mode
        const right = new THREE.Vector3();
        const up = new THREE.Vector3(0, 1, 0);
        camera.getWorldDirection(right);
        right.cross(up).normalize();
        
        const panSpeed = 0.05;
        const panX = right.clone().multiplyScalar(-deltaX * panSpeed);
        const panY = up.clone().multiplyScalar(deltaY * panSpeed);
        
        camera.position.add(panX).add(panY);
        cameraTarget.add(panX).add(panY);
      } else {
        // Rotate mode
        const offset = new THREE.Vector3().subVectors(camera.position, cameraTarget);
        const spherical = new THREE.Spherical().setFromVector3(offset);
        
        spherical.theta -= deltaX * 0.01;
        spherical.phi += deltaY * 0.01;
        spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi));
        
        offset.setFromSpherical(spherical);
        camera.position.copy(cameraTarget).add(offset);
      }
      
      camera.lookAt(cameraTarget);
      mouseX = e.clientX;
      mouseY = e.clientY;
      state.view3D.needsRender = true;
    });
    
    container.addEventListener('mouseup', () => {
      mouseDown = false;
    });
    
    container.addEventListener('wheel', (e) => {
      e.preventDefault();
      const { camera, cameraTarget } = state.view3D;
      const offset = new THREE.Vector3().subVectors(camera.position, cameraTarget);
      const distance = offset.length();
      const newDistance = utils.clamp(distance + e.deltaY * 0.01, 5, 100);
      
      offset.normalize().multiplyScalar(newDistance);
      camera.position.copy(cameraTarget).add(offset);
      camera.lookAt(cameraTarget);
      state.view3D.needsRender = true;
    });
    
    container.setAttribute('tabindex', '0');
    container.style.outline = 'none';
    
    // Keyboard controls
    window.addEventListener('keydown', (e) => {
      if (!state.view3D.enabled) return;
      state.view3D.keys[e.key.toLowerCase()] = true;
    });
    
    window.addEventListener('keyup', (e) => {
      if (!state.view3D.enabled) return;
      state.view3D.keys[e.key.toLowerCase()] = false;
    });
  },

  startAnimationLoop() {
    const animate = () => {
      requestAnimationFrame(animate);
      
      if (!state.view3D.enabled) return;
      
      // Process keyboard movement
      const { camera, cameraTarget, keys } = state.view3D;
      let moved = false;
      const forward = new THREE.Vector3();
      const right = new THREE.Vector3();
      
      camera.getWorldDirection(forward);
      forward.y = 0;
      forward.normalize();
      
      right.crossVectors(forward, new THREE.Vector3(0, 1, 0)).normalize();
      
      if (keys['w'] || keys['arrowup']) {
        camera.position.addScaledVector(forward, CONSTANTS.CAMERA_MOVE_SPEED);
        cameraTarget.addScaledVector(forward, CONSTANTS.CAMERA_MOVE_SPEED);
        moved = true;
      }
      if (keys['s'] || keys['arrowdown']) {
        camera.position.addScaledVector(forward, -CONSTANTS.CAMERA_MOVE_SPEED);
        cameraTarget.addScaledVector(forward, -CONSTANTS.CAMERA_MOVE_SPEED);
        moved = true;
      }
      if (keys['a'] || keys['arrowleft']) {
        camera.position.addScaledVector(right, -CONSTANTS.CAMERA_MOVE_SPEED);
        cameraTarget.addScaledVector(right, -CONSTANTS.CAMERA_MOVE_SPEED);
        moved = true;
      }
      if (keys['d'] || keys['arrowright']) {
        camera.position.addScaledVector(right, CONSTANTS.CAMERA_MOVE_SPEED);
        cameraTarget.addScaledVector(right, CONSTANTS.CAMERA_MOVE_SPEED);
        moved = true;
      }
      if (keys['q']) {
        camera.position.y += CONSTANTS.CAMERA_MOVE_SPEED;
        cameraTarget.y += CONSTANTS.CAMERA_MOVE_SPEED;
        moved = true;
      }
      if (keys['e']) {
        camera.position.y -= CONSTANTS.CAMERA_MOVE_SPEED;
        cameraTarget.y -= CONSTANTS.CAMERA_MOVE_SPEED;
        moved = true;
      }
      
      if (moved) {
        camera.lookAt(cameraTarget);
        state.view3D.needsRender = true;
      }
      
      // Render only when needed
      if (state.view3D.needsRender) {
        this.render();
        state.view3D.needsRender = false;
      }
    };
    
    animate();
  },

  render() {
    const { renderer, scene, camera } = state.view3D;
    if (renderer && scene && camera) {
      renderer.render(scene, camera);
    }
  },

  generateStaircase() {
    if (!state.view3D.scene) return;
    
    // Clear existing objects
    const existingObjects = state.view3D.scene.children.filter(child => 
      child.userData.isBlock || child.userData.isEllipse
    );
    existingObjects.forEach(obj => state.view3D.scene.remove(obj));
    
    const ellipseData = render2D.getEllipseData();
    const isDark = utils.isDarkTheme();
    const blockMaterial = new THREE.MeshLambertMaterial({ 
      color: isDark ? 0xe6e0e9 : 0x1d1b20 
    });
    
    const { showSingleStep, direction, stepHeight, startingSpoke } = state.view3D;
    const { total: totalSpokes } = state.spokes;
    const totalSteps = totalSpokes * state.view3D.rotations;
    
    const endStep = showSingleStep ? state.spokes.current : totalSteps - 1;
    
    for (let step = 0; step <= endStep; step++) {
      const spokeIndex = (startingSpoke + step) % totalSpokes;
      const y = step * stepHeight * direction * 0.5;
      
      this.generateLevelBlocks(ellipseData, spokeIndex, y, blockMaterial);
      this.drawEllipseRing(ellipseData.radiusX * 0.5, ellipseData.radiusY * 0.5, y, 
        isDark ? 0xf2b8b5 : 0xd32f2f, CONSTANTS.OPACITY.ELLIPSE_OUTLINE);
      this.drawEllipseRing(ellipseData.innerRadiusX * 0.5, ellipseData.innerRadiusY * 0.5, y, 
        isDark ? 0xa8c7fa : 0x1565c0, CONSTANTS.OPACITY.ELLIPSE_OUTLINE);
    }
    
    state.view3D.needsRender = true;
  },

  generateLevelBlocks(ellipseData, spokeIndex, height, material) {
    const { width: ew, height: eh, centerX: cx, centerY: cy, 
            radiusX: rx, radiusY: ry, innerRadiusX: inner_rx, innerRadiusY: inner_ry } = ellipseData;
    
    const arr_outer = utils.make2dArray(eh);
    const arr_inner = utils.make2dArray(eh);
    const arr_spokes = utils.make2dArray(eh);
    const arr_hole = utils.make2dArray(eh);
    
    // Initialize arrays
    for (let j = 0; j < eh; j++) {
      for (let i = 0; i < ew; i++) {
        arr_outer[j][i] = false;
        arr_inner[j][i] = false;
        arr_spokes[j][i] = false;
        arr_hole[j][i] = false;
      }
    }
    
    // Outer and inner ellipse rings
    for (let j = 0; j < eh; j++) {
      for (let i = 0; i < ew; i++) {
        if (utils.through(i, j, cx, cy, rx, ry)) arr_outer[j][i] = true;
        if (utils.through(i, j, cx, cy, inner_rx, inner_ry)) arr_inner[j][i] = true;
      }
    }
    
    // Generate spoke pattern
    if (state.spokes.fillSteps) {
      utils.fillWedgeBetweenSpokes(arr_spokes, spokeIndex, cx, cy, inner_rx, inner_ry, rx, ry, state.spokes.total);
    } else {
      const angle = (spokeIndex / state.spokes.total) * 2 * Math.PI;
      const endX = cx + rx * Math.cos(angle);
      const endY = cy + ry * Math.sin(angle);
      utils.plotLine(cx, cy, endX, endY, arr_spokes);
    }
    
    // Mark inner hole
    for (let j = 0; j < eh; j++) {
      for (let i = 0; i < ew; i++) {
        if (utils.inside(i, j, cx, cy, inner_rx, inner_ry)) {
          arr_hole[j][i] = true;
        }
      }
    }
    
    const isDark = utils.isDarkTheme();
    const materials = {
      outer: new THREE.MeshLambertMaterial({ 
        color: isDark ? 0xf2b8b5 : 0xd32f2f,
        transparent: true,
        opacity: CONSTANTS.OPACITY.OUTER_RING
      }),
      inner: new THREE.MeshLambertMaterial({ 
        color: isDark ? 0xa8c7fa : 0x1565c0,
        transparent: true,
        opacity: CONSTANTS.OPACITY.INNER_RING
      })
    };
    
    const scaleX = (ellipseData.radiusX * 2 * 0.5) / ew;
    const scaleZ = (ellipseData.radiusY * 2 * 0.5) / eh;
    
    // Collect positions
    const positions = {
      outer: [],
      inner: [],
      spoke: []
    };
    
    for (let j = 0; j < eh; j++) {
      for (let i = 0; i < ew; i++) {
        const x = (i - cx) * scaleX;
        const z = (j - cy) * scaleZ;
        
        if (arr_outer[j][i]) positions.outer.push({ x, y: height, z });
        if (arr_inner[j][i]) positions.inner.push({ x, y: height, z });
        if (arr_spokes[j][i] && !arr_hole[j][i]) positions.spoke.push({ x, y: height, z });
      }
    }
    
    // Create instanced meshes
    const boxGeometry = new THREE.BoxGeometry(CONSTANTS.BLOCK_SIZE, CONSTANTS.BLOCK_SIZE, CONSTANTS.BLOCK_SIZE);
    const matrix = new THREE.Matrix4();
    
    this.createInstancedMesh(boxGeometry, materials.outer, positions.outer, matrix, false);
    this.createInstancedMesh(boxGeometry, materials.inner, positions.inner, matrix, false);
    this.createInstancedMesh(boxGeometry, material, positions.spoke, matrix, true);
  },

  createInstancedMesh(geometry, material, positions, matrix, withEdges) {
    if (positions.length === 0) return;
    
    const mesh = new THREE.InstancedMesh(geometry, material, positions.length);
    positions.forEach((pos, i) => {
      matrix.setPosition(pos.x, pos.y, pos.z);
      mesh.setMatrixAt(i, matrix);
    });
    
    if (withEdges) {
      mesh.castShadow = true;
      mesh.receiveShadow = true;
      
      // Add edges
      const edgeGeometry = new THREE.EdgesGeometry(geometry);
      const edgeMaterial = new THREE.LineBasicMaterial({ 
        color: utils.isDarkTheme() ? 0x49454f : 0xcac4d0,
        transparent: true,
        opacity: CONSTANTS.OPACITY.EDGE
      });
      const edgesMesh = new THREE.InstancedMesh(edgeGeometry, edgeMaterial, positions.length);
      positions.forEach((pos, i) => {
        matrix.setPosition(pos.x, pos.y, pos.z);
        edgesMesh.setMatrixAt(i, matrix);
      });
      edgesMesh.userData.isBlock = true;
      state.view3D.scene.add(edgesMesh);
    }
    
    mesh.userData.isBlock = true;
    state.view3D.scene.add(mesh);
  },

  drawEllipseRing(radiusX, radiusY, height, color, opacity) {
    const curve = new THREE.EllipseCurve(0, 0, radiusX, radiusY, 0, 2 * Math.PI, false, 0);
    const points = curve.getPoints(64);
    const geometry = new THREE.BufferGeometry().setFromPoints(points);
    const material = new THREE.LineBasicMaterial({ 
      color: color,
      transparent: true,
      opacity: opacity,
      linewidth: 2
    });
    
    const ellipse = new THREE.Line(geometry, material);
    ellipse.rotation.x = Math.PI / 2;
    ellipse.position.y = height;
    ellipse.userData.isEllipse = true;
    
    state.view3D.scene.add(ellipse);
  }
};

// ==================== CONTROL FUNCTIONS ====================
const controls = {
  adjustValue(elementId, getter, setter, delta, min, max) {
    let value = getter() + delta;
    value = utils.clamp(value, min, max);
    setter(value);
    document.getElementById(elementId).value = value;
    this.updateView();
  },

  getValue(elementId, getter, setter, min, max) {
    let value = parseInt(document.getElementById(elementId).value) || min;
    value = utils.clamp(value, min, max);
    setter(value);
    document.getElementById(elementId).value = value;
    this.updateView();
  },

  updateView() {
    if (state.view3D.enabled) {
      render3D.generateStaircase();
    } else {
      resizeCanvas();
    }
  },

  updateMirrorButton(buttonId, mirrored) {
    const button = document.getElementById(buttonId);
    if (!button) return;
    
    const icon = button.querySelector('.material-icons');
    if (!icon) return;
    
    if (mirrored) {
      button.classList.add('mirrored');
      icon.textContent = 'sync';
      button.title = 'Width/Height mirrored (click to separate)';
    } else {
      button.classList.remove('mirrored');
      icon.textContent = 'sync_disabled';
      button.title = 'Width/Height separate (click to mirror)';
    }
  }
};

// ==================== UI FUNCTIONS ====================
function incX() {
  controls.adjustValue('ellw', 
    () => state.ellipse.width, 
    (v) => { state.ellipse.width = v; if (state.ellipse.outerMirrored) state.ellipse.height = v; }, 
    1, CONSTANTS.MIN_ELLIPSE_SIZE, Infinity);
  if (state.ellipse.outerMirrored) document.getElementById('ellh').value = state.ellipse.width;
}

function decX() {
  controls.adjustValue('ellw', 
    () => state.ellipse.width, 
    (v) => { state.ellipse.width = v; if (state.ellipse.outerMirrored) state.ellipse.height = v; }, 
    -1, CONSTANTS.MIN_ELLIPSE_SIZE, Infinity);
  if (state.ellipse.outerMirrored) document.getElementById('ellh').value = state.ellipse.width;
}

function getX() {
  controls.getValue('ellw', 
    () => state.ellipse.width, 
    (v) => { state.ellipse.width = v; if (state.ellipse.outerMirrored) state.ellipse.height = v; }, 
    CONSTANTS.MIN_ELLIPSE_SIZE, Infinity);
  if (state.ellipse.outerMirrored) document.getElementById('ellh').value = state.ellipse.width;
}

function incY() {
  controls.adjustValue('ellh', 
    () => state.ellipse.height, 
    (v) => { state.ellipse.height = v; if (state.ellipse.outerMirrored) state.ellipse.width = v; }, 
    1, CONSTANTS.MIN_ELLIPSE_SIZE, Infinity);
  if (state.ellipse.outerMirrored) document.getElementById('ellw').value = state.ellipse.height;
}

function decY() {
  controls.adjustValue('ellh', 
    () => state.ellipse.height, 
    (v) => { state.ellipse.height = v; if (state.ellipse.outerMirrored) state.ellipse.width = v; }, 
    -1, CONSTANTS.MIN_ELLIPSE_SIZE, Infinity);
  if (state.ellipse.outerMirrored) document.getElementById('ellw').value = state.ellipse.height;
}

function getY() {
  controls.getValue('ellh', 
    () => state.ellipse.height, 
    (v) => { state.ellipse.height = v; if (state.ellipse.outerMirrored) state.ellipse.width = v; }, 
    CONSTANTS.MIN_ELLIPSE_SIZE, Infinity);
  if (state.ellipse.outerMirrored) document.getElementById('ellw').value = state.ellipse.height;
}

function incInnerX() {
  controls.adjustValue('innerellw', 
    () => state.ellipse.innerWidth, 
    (v) => { state.ellipse.innerWidth = v; if (state.ellipse.innerMirrored) state.ellipse.innerHeight = v; }, 
    1, CONSTANTS.MIN_INNER_SIZE, Infinity);
  if (state.ellipse.innerMirrored) document.getElementById('innerellh').value = state.ellipse.innerWidth;
}

function decInnerX() {
  controls.adjustValue('innerellw', 
    () => state.ellipse.innerWidth, 
    (v) => { state.ellipse.innerWidth = v; if (state.ellipse.innerMirrored) state.ellipse.innerHeight = v; }, 
    -1, CONSTANTS.MIN_INNER_SIZE, Infinity);
  if (state.ellipse.innerMirrored) document.getElementById('innerellh').value = state.ellipse.innerWidth;
}

function getInnerX() {
  controls.getValue('innerellw', 
    () => state.ellipse.innerWidth, 
    (v) => { state.ellipse.innerWidth = v; if (state.ellipse.innerMirrored) state.ellipse.innerHeight = v; }, 
    CONSTANTS.MIN_INNER_SIZE, Infinity);
  if (state.ellipse.innerMirrored) document.getElementById('innerellh').value = state.ellipse.innerWidth;
}

function incInnerY() {
  controls.adjustValue('innerellh', 
    () => state.ellipse.innerHeight, 
    (v) => { state.ellipse.innerHeight = v; if (state.ellipse.innerMirrored) state.ellipse.innerWidth = v; }, 
    1, CONSTANTS.MIN_INNER_SIZE, Infinity);
  if (state.ellipse.innerMirrored) document.getElementById('innerellw').value = state.ellipse.innerHeight;
}

function decInnerY() {
  controls.adjustValue('innerellh', 
    () => state.ellipse.innerHeight, 
    (v) => { state.ellipse.innerHeight = v; if (state.ellipse.innerMirrored) state.ellipse.innerWidth = v; }, 
    -1, CONSTANTS.MIN_INNER_SIZE, Infinity);
  if (state.ellipse.innerMirrored) document.getElementById('innerellw').value = state.ellipse.innerHeight;
}

function getInnerY() {
  controls.getValue('innerellh', 
    () => state.ellipse.innerHeight, 
    (v) => { state.ellipse.innerHeight = v; if (state.ellipse.innerMirrored) state.ellipse.innerWidth = v; }, 
    CONSTANTS.MIN_INNER_SIZE, Infinity);
  if (state.ellipse.innerMirrored) document.getElementById('innerellw').value = state.ellipse.innerHeight;
}

function toggleOuterMirror() {
  state.ellipse.outerMirrored = !state.ellipse.outerMirrored;
  controls.updateMirrorButton('outer-mirror', state.ellipse.outerMirrored);
  if (state.ellipse.outerMirrored) {
    state.ellipse.height = state.ellipse.width;
    document.getElementById('ellh').value = state.ellipse.height;
    controls.updateView();
  }
}

function toggleInnerMirror() {
  state.ellipse.innerMirrored = !state.ellipse.innerMirrored;
  controls.updateMirrorButton('inner-mirror', state.ellipse.innerMirrored);
  if (state.ellipse.innerMirrored) {
    state.ellipse.innerHeight = state.ellipse.innerWidth;
    document.getElementById('innerellh').value = state.ellipse.innerHeight;
    controls.updateView();
  }
}

function incSpokes() {
  controls.adjustValue('spokes', 
    () => state.spokes.total, 
    (v) => state.spokes.total = v, 
    1, CONSTANTS.MIN_SPOKES, CONSTANTS.MAX_SPOKES);
}

function decSpokes() {
  controls.adjustValue('spokes', 
    () => state.spokes.total, 
    (v) => state.spokes.total = v, 
    -1, CONSTANTS.MIN_SPOKES, CONSTANTS.MAX_SPOKES);
}

function getSpokes() {
  controls.getValue('spokes', 
    () => state.spokes.total, 
    (v) => state.spokes.total = v, 
    CONSTANTS.MIN_SPOKES, CONSTANTS.MAX_SPOKES);
}

function nextSpoke() {
  state.spokes.current++;
  controls.updateView();
}

function prevSpoke() {
  state.spokes.current--;
  controls.updateView();
}

function incStepHeight() {
  controls.adjustValue('stepheight', 
    () => state.view3D.stepHeight, 
    (v) => state.view3D.stepHeight = v, 
    0.5, CONSTANTS.MIN_STEP_HEIGHT, CONSTANTS.MAX_STEP_HEIGHT);
}

function decStepHeight() {
  controls.adjustValue('stepheight', 
    () => state.view3D.stepHeight, 
    (v) => state.view3D.stepHeight = v, 
    -0.5, CONSTANTS.MIN_STEP_HEIGHT, CONSTANTS.MAX_STEP_HEIGHT);
}

function getStepHeight() {
  let value = parseFloat(document.getElementById('stepheight').value) || 1;
  value = utils.clamp(value, CONSTANTS.MIN_STEP_HEIGHT, CONSTANTS.MAX_STEP_HEIGHT);
  state.view3D.stepHeight = value;
  document.getElementById('stepheight').value = value;
  if (state.view3D.enabled) render3D.generateStaircase();
}

function incStartSpoke() {
  state.view3D.startingSpoke = (state.view3D.startingSpoke + 1) % state.spokes.total;
  document.getElementById('startspoke').value = state.view3D.startingSpoke;
  if (state.view3D.enabled) render3D.generateStaircase();
}

function decStartSpoke() {
  state.view3D.startingSpoke--;
  if (state.view3D.startingSpoke < 0) state.view3D.startingSpoke = state.spokes.total - 1;
  document.getElementById('startspoke').value = state.view3D.startingSpoke;
  if (state.view3D.enabled) render3D.generateStaircase();
}

function getStartSpoke() {
  let value = parseInt(document.getElementById('startspoke').value) || 0;
  value = utils.clamp(value, 0, state.spokes.total - 1);
  state.view3D.startingSpoke = value;
  document.getElementById('startspoke').value = value;
  if (state.view3D.enabled) render3D.generateStaircase();
}

function setDirection(direction) {
  state.view3D.direction = direction;
  document.querySelectorAll('.direction-btn').forEach(btn => btn.classList.remove('active'));
  document.getElementById(direction === 1 ? 'up-btn' : 'down-btn').classList.add('active');
  if (state.view3D.enabled) render3D.generateStaircase();
}

function toggleSingleStep() {
  state.view3D.showSingleStep = !state.view3D.showSingleStep;
  const button = document.getElementById('single-step-toggle');
  const spokeNavButtons = document.getElementById('spoke-nav-buttons');
  const startSpokeControl = document.getElementById('start-spoke-control');
  
  if (state.view3D.showSingleStep) {
    button.classList.add('mirrored');
    button.querySelector('.material-icons').textContent = 'filter_1';
    button.title = 'Showing single step (click to show all)';
    spokeNavButtons.style.display = 'flex';
    startSpokeControl.style.display = 'none';
  } else {
    button.classList.remove('mirrored');
    button.querySelector('.material-icons').textContent = 'view_carousel';
    button.title = 'Showing all steps (click to show single)';
    spokeNavButtons.style.display = 'none';
    startSpokeControl.style.display = 'flex';
  }
  if (state.view3D.enabled) render3D.generateStaircase();
}

function toggleViewMode() {
  state.view3D.enabled = !state.view3D.enabled;
  
  const canvas2D = document.getElementById('myCanvas');
  const scene3D = document.getElementById('scene3d');
  const toggleBtn = document.getElementById('view-toggle');
  const staircaseControls = document.getElementById('staircase-controls');
  const displaySection = document.getElementById('display-section');
  const spokeNavButtons = document.getElementById('spoke-nav-buttons');
  
  if (state.view3D.enabled) {
    canvas2D.style.display = 'none';
    scene3D.style.display = 'block';
    toggleBtn.classList.add('active');
    toggleBtn.innerHTML = '<span class="material-icons">view_in_ar</span> 3D Mode';
    staircaseControls.style.display = 'block';
    displaySection.style.display = 'none';
    
    if (!state.view3D.showSingleStep) {
      spokeNavButtons.style.display = 'none';
    }
    
    if (!state.view3D.scene) {
      render3D.init();
    } else {
      render3D.generateStaircase();
      if (state.view3D.renderer) {
        const container = document.getElementById('scene3d');
        const rect = container.getBoundingClientRect();
        state.view3D.renderer.setSize(rect.width, rect.height);
        state.view3D.camera.aspect = rect.width / rect.height;
        state.view3D.camera.updateProjectionMatrix();
        state.view3D.needsRender = true;
      }
    }
  } else {
    canvas2D.style.display = 'block';
    scene3D.style.display = 'none';
    toggleBtn.classList.remove('active');
    toggleBtn.innerHTML = '<span class="material-icons">grid_view</span> 2D Mode';
    staircaseControls.style.display = 'none';
    displaySection.style.display = 'block';
    spokeNavButtons.style.display = 'flex';
    resizeCanvas();
  }
}

function modeChange() {
  const e = document.getElementById('fitmode');
  state.canvas.fitMode = parseInt(e.options[e.selectedIndex].value);
  resizeCanvas();
}

function toggleTheme() {
  const currentTheme = document.documentElement.getAttribute('data-theme') || 'dark';
  const newTheme = currentTheme === 'light' ? 'dark' : 'light';
  
  document.documentElement.setAttribute('data-theme', newTheme);
  const themeIcon = document.getElementById('theme-icon');
  if (themeIcon) {
    themeIcon.textContent = newTheme === 'light' ? 'dark_mode' : 'light_mode';
  }
  
  if (state.view3D.enabled && state.view3D.scene) {
    state.view3D.scene.background = new THREE.Color(newTheme === 'dark' ? 0x141218 : 0xfefbff);
    render3D.generateStaircase();
  }
  
  controls.updateView();
}

// ==================== CANVAS MANAGEMENT ====================
function resizeCanvas() {
  const d = document.getElementById('canvas-container');
  const elHeight = d.clientHeight;
  const elWidth = d.clientWidth;
  
  if (state.view3D.enabled) {
    if (state.view3D.renderer) {
      state.view3D.renderer.setSize(elWidth, elHeight);
      state.view3D.camera.aspect = elWidth / elHeight;
      state.view3D.camera.updateProjectionMatrix();
      state.view3D.needsRender = true;
    }
    return;
  }
  
  let width = elWidth;
  let height = elHeight;
  const { width: ellipseWidth, height: ellipseHeight } = state.ellipse;
  const { fitMode, scale } = state.canvas;
  
  const h1 = height;
  const w1 = height * ellipseWidth / ellipseHeight;
  const w2 = width;
  const h2 = width * ellipseHeight / ellipseWidth;
  
  if (fitMode === 0) {
    if (w1 > w2) {
      width = w2;
      height = h2;
    } else {
      width = w1;
      height = h1;
    }
  } else if (fitMode === 1) {
    width = w2;
    height = h2;
  } else {
    width = w1;
    height = h1;
  }
  
  width *= scale[2];
  height *= scale[3];
  
  const can = document.getElementById('myCanvas');
  state.canvas.width = width;
  state.canvas.height = height;
  can.width = elWidth;
  can.height = elHeight;
  
  const ctx = can.getContext('2d');
  render2D.draw(ctx);
}

// Debounce resize events
let resizeTimeout;
window.addEventListener('resize', () => {
  clearTimeout(resizeTimeout);
  resizeTimeout = setTimeout(resizeCanvas, 100);
});

// ==================== MOUSE INTERACTION ====================
function relMouseCoords(currentElement, event) {
  let totalOffsetX = 0;
  let totalOffsetY = 0;
  let element = currentElement;

  do {
    totalOffsetX += element.offsetLeft - element.scrollLeft;
    totalOffsetY += element.offsetTop - element.scrollTop;
  } while (element = element.offsetParent);

  return {
    x: event.pageX - totalOffsetX,
    y: event.pageY - totalOffsetY
  };
}

function canvasMouseDown(event) {
  if (state.view3D.enabled) return;
  
  const can = document.getElementById('myCanvas');
  const coords = relMouseCoords(can, event);
  const { scale, width, height } = state.canvas;
  const { width: ellipseWidth, height: ellipseHeight } = state.ellipse;
  
  if (event.buttons !== null ? (event.buttons & 1) : (event.which === 1)) {
    state.canvas.selection[0] = state.canvas.selection[2] = parseInt((coords.x - scale[0]) * ellipseWidth / width);
    state.canvas.selection[1] = state.canvas.selection[3] = parseInt((coords.y - scale[1]) * ellipseHeight / height);
    state.canvas.makingSelection = true;
    resizeCanvas();
  } else if (event.buttons !== null ? (event.buttons & 2) : (event.which === 3)) {
    if (scale[2] > 1 || state.canvas.fitMode !== 0) {
      state.canvas.panData = [scale[0], scale[1], coords.x, coords.y];
      state.canvas.panning = true;
    } else {
      state.canvas.scale = [0, 0, 1, 1];
    }
    resizeCanvas();
  }
  
  return false;
}

function canvasMouseMove(event) {
  if (state.view3D.enabled) return;
  
  const can = document.getElementById('myCanvas');
  const coords = relMouseCoords(can, event);
  const { scale, width, height } = state.canvas;
  const { width: ellipseWidth, height: ellipseHeight } = state.ellipse;
  
  if (state.canvas.makingSelection) {
    state.canvas.selection[2] = parseInt((coords.x - scale[0]) * ellipseWidth / width);
    state.canvas.selection[3] = parseInt((coords.y - scale[1]) * ellipseHeight / height);
    resizeCanvas();
  } else if (state.canvas.panning) {
    state.canvas.scale[0] = state.canvas.panData[0] + (coords.x - state.canvas.panData[2]);
    state.canvas.scale[1] = state.canvas.panData[1] + (coords.y - state.canvas.panData[3]);
    resizeCanvas();
  }
  
  return false;
}

function canvasMouseUp(event) {
  if (state.view3D.enabled) return;
  
  if (state.canvas.makingSelection) {
    const can = document.getElementById('myCanvas');
    const coords = relMouseCoords(can, event);
    const { scale, width, height } = state.canvas;
    const { width: ellipseWidth, height: ellipseHeight } = state.ellipse;
    
    state.canvas.selection[2] = parseInt((coords.x - scale[0]) * ellipseWidth / width);
    state.canvas.selection[3] = parseInt((coords.y - scale[1]) * ellipseHeight / height);
    state.canvas.makingSelection = false;
    resizeCanvas();
  } else if (state.canvas.panning) {
    const can = document.getElementById('myCanvas');
    const coords = relMouseCoords(can, event);
    
    state.canvas.scale[0] = state.canvas.panData[0] + (coords.x - state.canvas.panData[2]);
    state.canvas.scale[1] = state.canvas.panData[1] + (coords.y - state.canvas.panData[3]);
    state.canvas.panning = false;
    resizeCanvas();
  }
  
  return false;
}

function mouseWheelHandler(e) {
  if (state.view3D.enabled) return;
  
  const can = document.getElementById('myCanvas');
  const coords = relMouseCoords(can, e);
  const delta = e.wheelDelta ? e.wheelDelta : -e.detail;
  const { scale } = state.canvas;
  
  if (delta < 0) {
    scale[2] *= 0.5;
    scale[3] *= 0.5;
    scale[0] = coords.x - (coords.x - scale[0]) * 0.5;
    scale[1] = coords.y - (coords.y - scale[1]) * 0.5;
  } else {
    scale[2] *= 2;
    scale[3] *= 2;
    scale[0] = coords.x - (coords.x - scale[0]) * 2;
    scale[1] = coords.y - (coords.y - scale[1]) * 2;
  }
  
  if (scale[2] <= 1) {
    scale[2] = 1;
    scale[3] = 1;
    scale[0] = 0;
    scale[1] = 0;
  }
  
  resizeCanvas();
  return false;
}

// ==================== INITIALIZATION ====================
function initCanvas() {
  document.getElementById('ellw').value = state.ellipse.width;
  document.getElementById('ellh').value = state.ellipse.height;
  document.getElementById('innerellw').value = state.ellipse.innerWidth;
  document.getElementById('innerellh').value = state.ellipse.innerHeight;
  document.getElementById('spokes').value = state.spokes.total;
  document.getElementById('stepheight').value = state.view3D.stepHeight;
  document.getElementById('startspoke').value = state.view3D.startingSpoke;
  
  setTimeout(() => {
    controls.updateMirrorButton('outer-mirror', state.ellipse.outerMirrored);
    controls.updateMirrorButton('inner-mirror', state.ellipse.innerMirrored);
    setDirection(1);
    
    const singleStepBtn = document.getElementById('single-step-toggle');
    if (singleStepBtn) {
      singleStepBtn.classList.remove('mirrored');
      singleStepBtn.querySelector('.material-icons').textContent = 'view_carousel';
    }
  }, 0);
  
  // Initialize theme
  document.documentElement.setAttribute('data-theme', 'dark');
  const themeIcon = document.getElementById('theme-icon');
  if (themeIcon) {
    themeIcon.textContent = 'light_mode';
  }
  
  resizeCanvas();
}

// Setup event listeners
window.addEventListener('load', () => {
  const can = document.getElementById('myCanvas');
  can.addEventListener('mousedown', canvasMouseDown);
  can.addEventListener('mousemove', canvasMouseMove);
  can.addEventListener('mouseup', canvasMouseUp);
  can.addEventListener('mouseleave', canvasMouseUp);
  can.addEventListener('mousewheel', mouseWheelHandler, false);
  can.addEventListener('DOMMouseScroll', mouseWheelHandler, false);
  can.addEventListener('contextmenu', (e) => e.preventDefault(), false);
  
  initCanvas();
});
</script>

</head>

<body>
    
<header class="top-app-bar">
    <h1>Ellipse & Staircase Generator</h1>
    <div class="header-controls">
        <button class="view-toggle" id="view-toggle" onclick="toggleViewMode()" title="Toggle 3D Mode">
            <span class="material-icons">grid_view</span> 2D Mode
        </button>
        <button class="theme-toggle" onclick="toggleTheme()" title="Toggle theme">
            <span class="material-icons" id="theme-icon">light_mode</span>
        </button>
    </div>
</header>

<div class="content">
    <div class="controls-panel">
        
        <div class="surface">
            <h2>Outer Ellipse</h2>
            <div class="control-group">
                <span class="label">Width</span>
                <button class="btn btn-filled" onclick="decX()"></button>
                <input type="text" id="ellw" class="input-field" onkeyup="getX()">
                <button class="btn btn-filled" onclick="incX()">+</button>
                <button class="btn btn-mirror" id="outer-mirror" onclick="toggleOuterMirror()">
                    <span class="material-icons">sync</span>
                </button>
            </div>
            <div class="control-group">
                <span class="label">Height</span>
                <button class="btn btn-filled" onclick="decY()"></button>
                <input type="text" id="ellh" class="input-field" onkeyup="getY()">
                <button class="btn btn-filled" onclick="incY()">+</button>
            </div>
        </div>

        <div class="surface">
            <h2>Inner Ellipse</h2>
            <div class="control-group">
                <span class="label">Width</span>
                <button class="btn btn-filled" onclick="decInnerX()"></button>
                <input type="text" id="innerellw" class="input-field" onkeyup="getInnerX()">
                <button class="btn btn-filled" onclick="incInnerX()">+</button>
                <button class="btn btn-mirror" id="inner-mirror" onclick="toggleInnerMirror()">
                    <span class="material-icons">sync</span>
                </button>
            </div>
            <div class="control-group">
                <span class="label">Height</span>
                <button class="btn btn-filled" onclick="decInnerY()"></button>
                <input type="text" id="innerellh" class="input-field" onkeyup="getInnerY()">
                <button class="btn btn-filled" onclick="incInnerY()">+</button>
            </div>
        </div>

        <div class="surface">
            <h2>Spokes</h2>
            <div class="control-group">
                <span class="label">Count</span>
                <button class="btn btn-filled" onclick="decSpokes()"></button>
                <input type="text" id="spokes" class="input-field" onkeyup="getSpokes()">
                <button class="btn btn-filled" onclick="incSpokes()">+</button>
            </div>
            <div class="spoke-controls" id="spoke-nav-buttons">
                <button class="btn btn-outlined" onclick="prevSpoke()">
                    <span class="material-icons">chevron_left</span>
                    Previous
                </button>
                <button class="btn btn-outlined" onclick="nextSpoke()">
                    Next
                    <span class="material-icons">chevron_right</span>
                </button>
            </div>
        </div>

        <div class="surface" id="staircase-controls" style="display: none;">
            <h2>3D Staircase</h2>
            
            <div class="control-group">
                <span class="label">View Mode</span>
                <button class="btn btn-mirror" id="single-step-toggle" onclick="toggleSingleStep()">
                    <span class="material-icons">view_carousel</span>
                </button>
            </div>
            
            <div class="control-group">
                <span class="label">Direction</span>
                <div class="direction-toggle">
                    <button class="direction-btn active" id="up-btn" onclick="setDirection(1)">
                        <span class="material-icons">arrow_upward</span>
                        Up
                    </button>
                    <button class="direction-btn" id="down-btn" onclick="setDirection(-1)">
                        <span class="material-icons">arrow_downward</span>
                        Down
                    </button>
                </div>
            </div>
            
            <div class="control-group">
                <span class="label">Step Height</span>
                <button class="btn btn-filled" onclick="decStepHeight()"></button>
                <input type="text" id="stepheight" class="input-field" onkeyup="getStepHeight()">
                <button class="btn btn-filled" onclick="incStepHeight()">+</button>
            </div>
            
            <div class="control-group" id="start-spoke-control">
                <span class="label">Start Spoke</span>
                <button class="btn btn-filled" onclick="decStartSpoke()"></button>
                <input type="text" id="startspoke" class="input-field" onkeyup="getStartSpoke()">
                <button class="btn btn-filled" onclick="incStartSpoke()">+</button>
            </div>
        </div>

        <div class="surface" id="display-section">
            <h2>Display</h2>
            <div class="control-group">
                <span class="label">Fit Mode</span>
                <div class="select">
                    <select id="fitmode" onchange="modeChange()">
                        <option value="0" selected>Fit to window</option>
                        <option value="1">Fit width</option>
                        <option value="2">Fit height</option>
                    </select>
                </div>
            </div>
        </div>

        <div class="instructions">
            <div class="instruction-row">
                <span class="material-icons">mouse</span>
                <span>2D: Click + drag to select</span>
            </div>
            <div class="instruction-row">
                <span class="material-icons">pan_tool</span>
                <span>2D: Right-click + drag to pan</span>
            </div>
            <div class="instruction-row">
                <span class="material-icons">zoom_in</span>
                <span>Mouse wheel to zoom</span>
            </div>
            <div class="instruction-row">
                <span class="material-icons">view_in_ar</span>
                <span>3D: Drag to rotate view</span>
            </div>
            <div class="instruction-row">
                <span class="material-icons">open_with</span>
                <span>3D: Shift+drag to pan camera</span>
            </div>
            <div class="instruction-row">
                <span class="material-icons">keyboard</span>
                <span>3D: WASD/Arrows to move, Q/E for up/down</span>
            </div>
        </div>

        <div class="surface" style="font-size: 12px; padding: 12px;">
            <div style="color: var(--on-surface-variant); line-height: 1.4;">
                <div style="margin-bottom: 8px;">
                    <strong>Based on the original work by:</strong><br>
                    Timothy Miller, Binghamton University
                </div>
                <div>
                    <a href="https://www.cs.binghamton.edu/~millerti/circlegen.html" 
                       target="_blank" 
                       style="color: var(--primary); text-decoration: none;"
                       onmouseover="this.style.textDecoration='underline'"
                       onmouseout="this.style.textDecoration='none'">
                        View Original Version 
                    </a>
                </div>
            </div>
        </div>

    </div>

    <div class="canvas-container" id="canvas-container">
        <canvas id="myCanvas"></canvas>
        <div id="scene3d"></div>
    </div>
</div>

</body>
</html>