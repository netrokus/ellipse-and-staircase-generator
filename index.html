<!DOCTYPE HTML>
<html>
<head>
<title>Ellipse and Staircase Generator</title>
<link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">

<style>
* {
  box-sizing: border-box;
}

:root {
  /* Light theme colors */
  --primary: #1565c0;
  --primary-hover: #1976d2;
  --primary-light: #bbdefb;
  --on-primary: #ffffff;
  --surface: #ffffff;
  --surface-variant: #f5f5f5;
  --on-surface: #1d1b20;
  --on-surface-variant: #49454f;
  --outline: #79747e;
  --outline-variant: #cac4d0;
  --background: #fefbff;
  --on-background: #1d1b20;
  --selection-bg: #e3f2fd;
  --grid-color: #e7e0ec;
  --canvas-bg: #fefbff;
  --canvas-surface: #ffffff;
  --ellipse-outer: #d32f2f;
  --ellipse-inner: #1565c0;
  --block-color: #1d1b20;
  --instruction-bg: #fff8e1;
  --instruction-border: #f9cc33;
  --instruction-text: #614a00;
  --shadow: rgba(0, 0, 0, 0.12);
  --shadow-strong: rgba(0, 0, 0, 0.16);
}

[data-theme="dark"] {
  /* Dark theme colors */
  --primary: #90caf9;
  --primary-hover: #64b5f6;
  --primary-light: #1e3a8a;
  --on-primary: #003d82;
  --surface: #1d1b20;
  --surface-variant: #141218;
  --on-surface: #e6e0e9;
  --on-surface-variant: #cac4d0;
  --outline: #938f99;
  --outline-variant: #49454f;
  --background: #141218;
  --on-background: #e6e0e9;
  --selection-bg: #2b2930;
  --grid-color: #49454f;
  --canvas-bg: #141218;
  --canvas-surface: #1d1b20;
  --ellipse-outer: #f2b8b5;
  --ellipse-inner: #a8c7fa;
  --block-color: #e6e0e9;
  --instruction-bg: #3d2f00;
  --instruction-border: #6c5d00;
  --instruction-text: #ffd95a;
  --shadow: rgba(0, 0, 0, 0.3);
  --shadow-strong: rgba(0, 0, 0, 0.4);
}

html, body {
  margin: 0;
  padding: 0;
  font-family: 'Roboto', -apple-system, BlinkMacSystemFont, sans-serif;
  background-color: var(--background);
  color: var(--on-background);
  transition: background-color 0.3s ease, color 0.3s ease;
}

body {
  height: 100vh;
  display: flex;
  flex-direction: column;
}

.top-app-bar {
  background: var(--primary);
  color: var(--on-primary);
  padding: 16px 24px;
  elevation: 2;
  box-shadow: 0px 2px 4px var(--shadow);
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.top-app-bar h1 {
  margin: 0;
  font-size: 22px;
  font-weight: 400;
}

.header-controls {
  display: flex;
  gap: 8px;
  align-items: center;
}

.theme-toggle {
  background: none;
  border: none;
  color: var(--on-primary);
  cursor: pointer;
  padding: 8px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: background-color 0.2s ease;
}

.theme-toggle:hover {
  background: rgba(255, 255, 255, 0.1);
}

.theme-toggle .material-icons {
  font-size: 24px;
}

.view-toggle {
  background: rgba(255, 255, 255, 0.1);
  border: 1px solid rgba(255, 255, 255, 0.2);
  color: var(--on-primary);
  cursor: pointer;
  padding: 8px 16px;
  border-radius: 20px;
  display: flex;
  align-items: center;
  gap: 8px;
  transition: all 0.2s ease;
  font-size: 14px;
  font-weight: 500;
}

.view-toggle:hover {
  background: rgba(255, 255, 255, 0.2);
}

.view-toggle.active {
  background: var(--on-primary);
  color: var(--primary);
}

.content {
  flex: 1;
  display: flex;
  gap: 16px;
  padding: 16px;
  overflow: hidden;
}

.controls-panel {
  width: 320px;
  display: flex;
  flex-direction: column;
  gap: 16px;
  overflow-y: auto;
  overflow-x: hidden;
  padding-right: 8px;
}

.controls-panel::-webkit-scrollbar {
  width: 8px;
}

.controls-panel::-webkit-scrollbar-track {
  background: var(--surface-variant);
  border-radius: 4px;
}

.controls-panel::-webkit-scrollbar-thumb {
  background: var(--outline);
  border-radius: 4px;
}

.controls-panel::-webkit-scrollbar-thumb:hover {
  background: var(--outline-variant);
}

.surface {
  background: var(--surface);
  border-radius: 12px;
  padding: 16px;
  box-shadow: 0px 1px 3px var(--shadow);
  border: 1px solid var(--outline-variant);
  transition: background-color 0.3s ease, border-color 0.3s ease;
}

.surface h2 {
  margin: 0 0 16px 0;
  font-size: 16px;
  font-weight: 500;
  color: var(--primary);
}

.control-group {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 12px;
}

.control-group:last-child {
  margin-bottom: 0;
}

.btn {
  border: none;
  border-radius: 20px;
  padding: 8px 16px;
  font-family: inherit;
  font-weight: 500;
  font-size: 14px;
  cursor: pointer;
  transition: all 0.2s ease;
  min-width: 40px;
  height: 40px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.btn-filled {
  background: var(--primary);
  color: var(--on-primary);
}

.btn-filled:hover {
  background: var(--primary-hover);
  box-shadow: 0px 1px 3px var(--shadow-strong);
}

.btn-outlined {
  background: transparent;
  border: 1px solid var(--outline);
  color: var(--primary);
}

.btn-mirror {
  background: transparent;
  border: 1px solid var(--outline);
  color: var(--on-surface-variant);
  min-width: 40px;
  transition: all 0.2s ease;
}

.btn-mirror.mirrored {
  background: var(--primary);
  color: var(--on-primary);
  border-color: var(--primary);
  box-shadow: 0px 1px 3px var(--shadow);
}

.btn-mirror:hover {
  background: var(--selection-bg);
}

.btn-mirror.mirrored:hover {
  background: var(--primary-hover);
}

.input-field {
  width: 80px;
  height: 40px;
  border: 1px solid var(--outline);
  border-radius: 4px;
  padding: 0 12px;
  font-family: inherit;
  font-size: 14px;
  text-align: center;
  background: var(--surface);
  color: var(--on-surface);
  transition: border-color 0.2s ease, background-color 0.3s ease, color 0.3s ease;
}

.input-field:focus {
  outline: none;
  border-color: var(--primary);
  border-width: 2px;
}

.label {
  font-size: 12px;
  color: var(--on-surface-variant);
  font-weight: 500;
  min-width: 60px;
}

.canvas-container {
  flex: 1;
  background: var(--canvas-surface);
  border-radius: 12px;
  box-shadow: 0px 1px 3px var(--shadow);
  border: 1px solid var(--outline-variant);
  overflow: hidden;
  position: relative;
  transition: background-color 0.3s ease, border-color 0.3s ease;
}

#myCanvas, #scene3d {
  display: block;
  width: 100%;
  height: 100%;
}

#scene3d {
  display: none;
}

.spoke-controls {
  display: flex;
  gap: 8px;
}

.instructions {
  background: var(--instruction-bg);
  border: 1px solid var(--instruction-border);
  border-radius: 8px;
  padding: 12px;
  font-size: 13px;
  color: var(--instruction-text);
  transition: background-color 0.3s ease, border-color 0.3s ease, color 0.3s ease;
}

.instruction-row {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 4px;
}

.instruction-row:last-child {
  margin-bottom: 0;
}

.material-icons {
  font-size: 16px;
}

.divider {
  height: 1px;
  background: var(--outline-variant);
  margin: 16px 0;
}

.select {
  position: relative;
  width: 140px;
}

.select select {
  width: 100%;
  height: 40px;
  border: 1px solid var(--outline);
  border-radius: 4px;
  padding: 0 32px 0 12px;
  font-family: inherit;
  font-size: 14px;
  background: var(--surface);
  color: var(--on-surface);
  cursor: pointer;
  appearance: none;
  transition: border-color 0.2s ease, background-color 0.3s ease, color 0.3s ease;
}

.select::after {
  content: 'expand_more';
  font-family: 'Material Icons';
  position: absolute;
  right: 8px;
  top: 50%;
  transform: translateY(-50%);
  pointer-events: none;
  color: var(--on-surface-variant);
}

.select select:focus {
  outline: none;
  border-color: var(--primary);
  border-width: 2px;
}

.staircase-controls {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.direction-toggle {
  display: flex;
  gap: 4px;
  padding: 4px;
  background: var(--surface-variant);
  border-radius: 8px;
}

.direction-btn {
  flex: 1;
  padding: 8px 12px;
  border: none;
  border-radius: 4px;
  background: transparent;
  color: var(--on-surface-variant);
  cursor: pointer;
  transition: all 0.2s ease;
  font-size: 12px;
  font-weight: 500;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 4px;
}

.direction-btn.active {
  background: var(--primary);
  color: var(--on-primary);
  box-shadow: 0px 1px 2px var(--shadow);
}

.direction-btn:hover:not(.active) {
  background: var(--selection-bg);
}
</style>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
var ellipseWidth = 40
var ellipseHeight = 40
var innerEllipseWidth = 20
var innerEllipseHeight = 20
var canWidth = 100
var canHeight = 100
var selection = [-1, -1, -1, -1]
var makingSelection = false
var panning = false;
var fitMode = 0;
var scale = [0, 0, 1, 1]
var pan_data = [0, 0, 0, 0]
var currentSpokeIndex = 0;
var totalSpokes = 32;
var maxSpokes = 64;

// Initialize mirror state variables
var outerMirrored = true;
var innerMirrored = true;

// 3D Mode variables
var is3DMode = false;
var scene, camera, renderer, controls;
var staircaseDirection = 1; // 1 for up, -1 for down
var stepHeight = 1;
var startingSpoke = 0;
var rotations = 2;
var cameraTarget = new THREE.Vector3(0, 0, 0);
var keys = {};
var moveSpeed = 0.5;

function paintGrid(ctx) {
    ctx.beginPath();
    ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--grid-color').trim();
    ctx.lineWidth = 1;
    for (let i=0; i<=ellipseWidth; i++) {
        let x = (i * canWidth) / ellipseWidth;
        if (x >= canWidth) x = canWidth-1;
        ctx.moveTo(x+0.5 + scale[0], scale[1]);
        ctx.lineTo(x+0.5 + scale[0], canHeight + scale[1]);
    }
    for (let i=0; i<=ellipseHeight; i++) {
        let y = (i * canHeight) / ellipseHeight;
        if (y >= canHeight) y = canHeight-1;
        ctx.moveTo(scale[0],y+0.5 + scale[1]);
        ctx.lineTo(canWidth + scale[0], y+0.5 + scale[1]);
    }
    ctx.stroke();
}

function selectedBlock(ctx, x, y) {
    let x1 = (x * canWidth) / ellipseWidth
    let y1 = (y * canHeight) / ellipseHeight
    let x2 = ((x+1) * canWidth) / ellipseWidth
    let y2 = ((y+1) * canHeight) / ellipseHeight
    let w = x2 - x1 + 0.75
    let h = y2 - y1 + 0.75
    ctx.fillRect(x1 + scale[0], y1 + scale[1], w, h)
}

function fullBlock(ctx, x, y) {
    let x1 = (x * canWidth) / ellipseWidth
    let y1 = (y * canHeight) / ellipseHeight
    let x2 = ((x+1) * canWidth) / ellipseWidth
    let y2 = ((y+1) * canHeight) / ellipseHeight
    
    let w = x2 - x1 + 0.75
    let h = y2 - y1 + 0.75
    
    ctx.fillRect(x1 + scale[0], y1 + scale[1], w, h)
}

function make2dArray(len){
    var a = [];
    for(let i = 0; i < len; i++) {
        a.push([]);
    }
    return a;
}

function inside(x, y, cx, cy, rx, ry) {
    if (rx <= 0 || ry <= 0) return false;
    y = (y - cy) / ry;
    x = (x - cx) / rx;
    return (x*x + y*y < 1);
}

function through(x, y, cx, cy, rx, ry) {
    let a =  inside(x-0.5, y-0.5, cx, cy, rx, ry);
    a += inside(x+0.5, y-0.5, cx, cy, rx, ry);
    a += inside(x-0.5, y+0.5, cx, cy, rx, ry);
    a += inside(x+0.5, y+0.5, cx, cy, rx, ry);
    
    return (a != 0) && (a != 4);
}

function between(x, a, b) {
    if (x >= a && x <= b) return true;
    if (x >= b && x <= a) return true;
    return false;
}

function plotLine(x0, y0, x1, y1, grid) {
    let dx = x1 - x0;
    let dy = y1 - y0;

    let steps = Math.max(Math.abs(dx), Math.abs(dy));
    if (steps === 0) {
        let gridX = Math.round(x0);
        let gridY = Math.round(y0);
        if (grid[gridY]) grid[gridY][gridX] = true;
        return;
    }

    let xIncrement = dx / steps;
    let yIncrement = dy / steps;

    let x = x0;
    let y = y0;

    for (let i = 0; i <= steps; i++) {
        let gridX = Math.round(x);
        let gridY = Math.round(y);
        if (grid[gridY] && gridX >= 0 && gridX < grid[gridY].length && gridY >= 0) {
            grid[gridY][gridX] = true;
        }
        x += xIncrement;
        y += yIncrement;
    }
}

function getEllipseData() {
    let ew = ellipseWidth;
    let eh = ellipseHeight;
    let inner_ew = innerEllipseWidth;
    let inner_eh = innerEllipseHeight;

    const arr_final = make2dArray(eh);
    
    for (let j = 0; j < eh; j++) {
        for (let i = 0; i < ew; i++) {
            arr_final[j][i] = false;
        }
    }

    const cx = ew / 2.0 - 0.5;
    const cy = eh / 2.0 - 0.5;    
    const rx = ew / 2.0;
    const ry = eh / 2.0;
    const inner_rx = inner_ew / 2.0;
    const inner_ry = inner_eh / 2.0;
    
    // Outer ellipse
    for (let j = 0; j < eh; j++) {
        for (let i = 0; i < ew; i++) {
            if (through(i, j, cx, cy, rx, ry)) {
                arr_final[j][i] = true;
            }
            if (through(i, j, cx, cy, inner_rx, inner_ry)) {
                arr_final[j][i] = true;
            }
        }
    }
    
    // Add current spoke if not in 3D mode
    if (!is3DMode) {
        if (currentSpokeIndex >= totalSpokes) { currentSpokeIndex = 0; }
        if (currentSpokeIndex < 0) { currentSpokeIndex = totalSpokes - 1; }

        const arr_spokes = make2dArray(eh);
        const arr_hole = make2dArray(eh);
        
        for (let j = 0; j < eh; j++) {
            for (let i = 0; i < ew; i++) {
                arr_spokes[j][i] = false;
                arr_hole[j][i] = false;
            }
        }

        const angle = (currentSpokeIndex / totalSpokes) * 2 * Math.PI;
        const endX = cx + rx * Math.cos(angle);
        const endY = cy + ry * Math.sin(angle);

        plotLine(cx, cy, endX, endY, arr_spokes);

        for (let j = 0; j < eh; j++) {
            for (let i = 0; i < ew; i++) {
                if (inside(i, j, cx, cy, inner_rx, inner_ry)) {
                    arr_hole[j][i] = true;
                }
            }
        }

        for (let j = 0; j < eh; j++) {
            for (let i = 0; i < ew; i++) {
                if (arr_spokes[j] && arr_spokes[j][i] && !(arr_hole[j] && arr_hole[j][i])) {
                    arr_final[j][i] = true;
                }
            }
        }
    }

    return {
        data: arr_final,
        width: ew,
        height: eh,
        centerX: cx,
        centerY: cy,
        radiusX: rx,
        radiusY: ry,
        innerRadiusX: inner_rx,
        innerRadiusY: inner_ry
    };
}

function circle2(ctx) {
    const ellipseData = getEllipseData();
    const arr_final = ellipseData.data;
    const ew = ellipseData.width;
    const eh = ellipseData.height;

    // Get theme colors from CSS variables
    const rootStyles = getComputedStyle(document.documentElement);
    const canvasBg = rootStyles.getPropertyValue('--canvas-bg').trim();
    const selectionBg = rootStyles.getPropertyValue('--selection-bg').trim();
    const blockColor = rootStyles.getPropertyValue('--block-color').trim();
    const ellipseOuter = rootStyles.getPropertyValue('--ellipse-outer').trim();
    const ellipseInner = rootStyles.getPropertyValue('--ellipse-inner').trim();

    ctx.fillStyle = canvasBg;
    ctx.fillRect(scale[0], scale[1], canWidth, canHeight);
    ctx.fillStyle = selectionBg;

    for (let j = 0; j < ellipseHeight; j++) {
        for (let i = 0; i < ellipseWidth; i++) {
            let inSelection = between(i, selection[0], selection[2]) && between(j, selection[1], selection[3]);
            if (inSelection) {
                selectedBlock(ctx, i, j);
            }
        }
    }
    
    ctx.fillStyle = blockColor;
    for (let j = 0; j < eh; j++) {
        for (let i = 0; i < ew; i++) {
            if (arr_final[j] && arr_final[j][i]) {
                fullBlock(ctx, i, j);
            }
        }
    }
    
    ctx.beginPath();
    ctx.strokeStyle = ellipseOuter;
    ctx.lineWidth = 2;
    ctx.ellipse((ellipseData.centerX + 0.5) * canWidth / ew + scale[0], 
                (ellipseData.centerY + 0.5) * canHeight / eh + scale[1], 
                ellipseData.radiusX * canWidth / ew, 
                ellipseData.radiusY * canHeight / eh, 0, 0, 2 * Math.PI);
    ctx.stroke();

    ctx.beginPath();
    ctx.strokeStyle = ellipseInner;
    ctx.lineWidth = 2;
    ctx.ellipse((ellipseData.centerX + 0.5) * canWidth / ew + scale[0], 
                (ellipseData.centerY + 0.5) * canHeight / eh + scale[1], 
                ellipseData.innerRadiusX * canWidth / ew, 
                ellipseData.innerRadiusY * canHeight / eh, 0, 0, 2 * Math.PI);
    ctx.stroke();

    paintGrid(ctx);
}

function init3D() {
    const container = document.getElementById('scene3d');
    const rect = container.getBoundingClientRect();
    
    // Scene setup
    scene = new THREE.Scene();
    const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
    scene.background = new THREE.Color(isDark ? 0x141218 : 0xfefbff);
    
    // Camera setup
    camera = new THREE.PerspectiveCamera(75, rect.width / rect.height, 0.1, 1000);
    camera.position.set(20, 15, 20);
    
    // Reset camera target
    cameraTarget.set(0, 0, 0);
    camera.lookAt(cameraTarget);
    
    // Renderer setup
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(rect.width, rect.height);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    
    container.appendChild(renderer.domElement);
    
    // Lighting
    const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
    scene.add(ambientLight);
    
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(50, 50, 25);
    directionalLight.castShadow = true;
    directionalLight.shadow.mapSize.width = 2048;
    directionalLight.shadow.mapSize.height = 2048;
    scene.add(directionalLight);
    
    // Mouse controls
    let mouseDown = false;
    let mouseX = 0;
    let mouseY = 0;
    
    container.addEventListener('mousedown', (e) => {
        mouseDown = true;
        mouseX = e.clientX;
        mouseY = e.clientY;
        container.focus();
    });
    
    container.addEventListener('mousemove', (e) => {
        if (!mouseDown) return;
        
        const deltaX = e.clientX - mouseX;
        const deltaY = e.clientY - mouseY;
        
        if (e.shiftKey) {
            // Pan mode: move camera and target together
            const right = new THREE.Vector3();
            const up = new THREE.Vector3(0, 1, 0);
            camera.getWorldDirection(right);
            right.cross(up).normalize();
            
            const panSpeed = 0.05;
            const panX = right.clone().multiplyScalar(-deltaX * panSpeed);
            const panY = up.clone().multiplyScalar(deltaY * panSpeed);
            
            camera.position.add(panX).add(panY);
            cameraTarget.add(panX).add(panY);
        } else {
            // Rotate mode: orbit around target
            const offset = new THREE.Vector3().subVectors(camera.position, cameraTarget);
            const spherical = new THREE.Spherical().setFromVector3(offset);
            
            spherical.theta -= deltaX * 0.01;
            spherical.phi += deltaY * 0.01;
            spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi));
            
            offset.setFromSpherical(spherical);
            camera.position.copy(cameraTarget).add(offset);
        }
        
        camera.lookAt(cameraTarget);
        
        mouseX = e.clientX;
        mouseY = e.clientY;
        
        render3D();
    });
    
    container.addEventListener('mouseup', () => {
        mouseDown = false;
    });
    
    container.addEventListener('wheel', (e) => {
        e.preventDefault();
        const offset = new THREE.Vector3().subVectors(camera.position, cameraTarget);
        const distance = offset.length();
        const newDistance = distance + e.deltaY * 0.01;
        
        offset.normalize().multiplyScalar(Math.max(5, Math.min(100, newDistance)));
        camera.position.copy(cameraTarget).add(offset);
        camera.lookAt(cameraTarget);
        render3D();
    });
    
    // Make container focusable
    container.setAttribute('tabindex', '0');
    container.style.outline = 'none';
    
    // Keyboard controls
    window.addEventListener('keydown', (e) => {
        if (!is3DMode) return;
        keys[e.key.toLowerCase()] = true;
    });
    
    window.addEventListener('keyup', (e) => {
        if (!is3DMode) return;
        keys[e.key.toLowerCase()] = false;
    });
    
    // Animation loop for keyboard movement
    function animate() {
        requestAnimationFrame(animate);
        
        if (!is3DMode) return;
        
        let moved = false;
        const forward = new THREE.Vector3();
        const right = new THREE.Vector3();
        
        camera.getWorldDirection(forward);
        forward.y = 0;
        forward.normalize();
        
        right.crossVectors(forward, new THREE.Vector3(0, 1, 0)).normalize();
        
        // WASD / Arrow keys movement
        if (keys['w'] || keys['arrowup']) {
            camera.position.addScaledVector(forward, moveSpeed);
            cameraTarget.addScaledVector(forward, moveSpeed);
            moved = true;
        }
        if (keys['s'] || keys['arrowdown']) {
            camera.position.addScaledVector(forward, -moveSpeed);
            cameraTarget.addScaledVector(forward, -moveSpeed);
            moved = true;
        }
        if (keys['a'] || keys['arrowleft']) {
            camera.position.addScaledVector(right, -moveSpeed);
            cameraTarget.addScaledVector(right, -moveSpeed);
            moved = true;
        }
        if (keys['d'] || keys['arrowright']) {
            camera.position.addScaledVector(right, moveSpeed);
            cameraTarget.addScaledVector(right, moveSpeed);
            moved = true;
        }
        if (keys['q']) {
            camera.position.y += moveSpeed;
            cameraTarget.y += moveSpeed;
            moved = true;
        }
        if (keys['e']) {
            camera.position.y -= moveSpeed;
            cameraTarget.y -= moveSpeed;
            moved = true;
        }
        
        if (moved) {
            camera.lookAt(cameraTarget);
            render3D();
        }
    }
    
    animate();
    generate3DStaircase();
}

function generate3DStaircase() {
    if (!scene) return;
    
    // Clear existing objects
    const existingObjects = scene.children.filter(child => 
        child.userData.isBlock || child.userData.isEllipse || child.userData.isSpoke
    );
    existingObjects.forEach(obj => scene.remove(obj));
    
    const ellipseData = getEllipseData();
    const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
    
    // Block material
    const blockMaterial = new THREE.MeshLambertMaterial({ 
        color: isDark ? 0xe6e0e9 : 0x1d1b20 
    });
    
    // Generate staircase with full block structure at each level
    const totalSteps = totalSpokes * rotations;
    
    for (let step = 0; step < totalSteps; step++) {
        const spokeIndex = (startingSpoke + step) % totalSpokes;
        const y = step * stepHeight * staircaseDirection * 0.5;
        
        // Generate all blocks for this level
        generateLevelBlocks(ellipseData, spokeIndex, y, blockMaterial);
        
        // Draw ellipse outlines at this level
        drawEllipseRing(ellipseData.radiusX * 0.5, ellipseData.radiusY * 0.5, y, isDark ? 0xf2b8b5 : 0xd32f2f, 0.3);
        drawEllipseRing(ellipseData.innerRadiusX * 0.5, ellipseData.innerRadiusY * 0.5, y, isDark ? 0xa8c7fa : 0x1565c0, 0.3);
    }
    
    render3D();
}

function generateLevelBlocks(ellipseData, spokeIndex, height, material) {
    const ew = ellipseData.width;
    const eh = ellipseData.height;
    const cx = ellipseData.centerX;
    const cy = ellipseData.centerY;
    const rx = ellipseData.radiusX;
    const ry = ellipseData.radiusY;
    const inner_rx = ellipseData.innerRadiusX;
    const inner_ry = ellipseData.innerRadiusY;
    
    // Create the 2D pattern for this level
    const arr_outer = make2dArray(eh);
    const arr_inner = make2dArray(eh);
    const arr_spokes = make2dArray(eh);
    const arr_hole = make2dArray(eh);
    
    for (let j = 0; j < eh; j++) {
        for (let i = 0; i < ew; i++) {
            arr_outer[j][i] = false;
            arr_inner[j][i] = false;
            arr_spokes[j][i] = false;
            arr_hole[j][i] = false;
        }
    }
    
    // Outer ellipse ring (separate from spoke)
    for (let j = 0; j < eh; j++) {
        for (let i = 0; i < ew; i++) {
            if (through(i, j, cx, cy, rx, ry)) {
                arr_outer[j][i] = true;
            }
        }
    }
    
    // Inner ellipse ring (separate from spoke)
    for (let j = 0; j < eh; j++) {
        for (let i = 0; i < ew; i++) {
            if (through(i, j, cx, cy, inner_rx, inner_ry)) {
                arr_inner[j][i] = true;
            }
        }
    }
    
    // Add spoke for this level
    const angle = (spokeIndex / totalSpokes) * 2 * Math.PI;
    const endX = cx + rx * Math.cos(angle);
    const endY = cy + ry * Math.sin(angle);
    plotLine(cx, cy, endX, endY, arr_spokes);
    
    // Mark inner hole
    for (let j = 0; j < eh; j++) {
        for (let i = 0; i < ew; i++) {
            if (inside(i, j, cx, cy, inner_rx, inner_ry)) {
                arr_hole[j][i] = true;
            }
        }
    }
    
    // Create transparent materials for rings
    const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
    const outerMaterial = new THREE.MeshLambertMaterial({ 
        color: isDark ? 0xf2b8b5 : 0xd32f2f,
        transparent: true,
        opacity: 0.1
    });
    const innerMaterial = new THREE.MeshLambertMaterial({ 
        color: isDark ? 0xa8c7fa : 0x1565c0,
        transparent: true,
        opacity: 0.3
    });
    
    // Use merged geometries for performance
    const blockSize = 0.5;
    const scaleX = (ellipseData.radiusX * 2 * 0.5) / ew;
    const scaleZ = (ellipseData.radiusY * 2 * 0.5) / eh;
    
    // Collect all positions first
    const outerPositions = [];
    const innerPositions = [];
    const spokePositions = [];
    
    for (let j = 0; j < eh; j++) {
        for (let i = 0; i < ew; i++) {
            const x = (i - cx) * scaleX;
            const z = (j - cy) * scaleZ;
            
            if (arr_outer[j] && arr_outer[j][i]) {
                outerPositions.push({ x, y: height, z });
            }
            
            if (arr_inner[j] && arr_inner[j][i]) {
                innerPositions.push({ x, y: height, z });
            }
            
            if (arr_spokes[j] && arr_spokes[j][i] && !(arr_hole[j] && arr_hole[j][i])) {
                spokePositions.push({ x, y: height, z });
            }
        }
    }
    
    // Create instanced meshes for better performance
    const boxGeometry = new THREE.BoxGeometry(blockSize, blockSize * 0.5, blockSize);
    
    if (outerPositions.length > 0) {
        const outerMesh = new THREE.InstancedMesh(boxGeometry, outerMaterial, outerPositions.length);
        const matrix = new THREE.Matrix4();
        outerPositions.forEach((pos, i) => {
            matrix.setPosition(pos.x, pos.y, pos.z);
            outerMesh.setMatrixAt(i, matrix);
        });
        outerMesh.userData.isBlock = true;
        scene.add(outerMesh);
    }
    
    if (innerPositions.length > 0) {
        const innerMesh = new THREE.InstancedMesh(boxGeometry, innerMaterial, innerPositions.length);
        const matrix = new THREE.Matrix4();
        innerPositions.forEach((pos, i) => {
            matrix.setPosition(pos.x, pos.y, pos.z);
            innerMesh.setMatrixAt(i, matrix);
        });
        innerMesh.userData.isBlock = true;
        scene.add(innerMesh);
    }
    
    if (spokePositions.length > 0) {
        const spokeMesh = new THREE.InstancedMesh(boxGeometry, material, spokePositions.length);
        const matrix = new THREE.Matrix4();
        spokePositions.forEach((pos, i) => {
            matrix.setPosition(pos.x, pos.y, pos.z);
            spokeMesh.setMatrixAt(i, matrix);
        });
        spokeMesh.castShadow = true;
        spokeMesh.receiveShadow = true;
        spokeMesh.userData.isBlock = true;
        scene.add(spokeMesh);
    }
}

function drawEllipseRing(radiusX, radiusY, height, color, opacity) {
    const curve = new THREE.EllipseCurve(
        0, 0,              // center x, y
        radiusX, radiusY,  // x radius, y radius
        0, 2 * Math.PI,    // start angle, end angle
        false,             // clockwise
        0                  // rotation
    );
    
    const points = curve.getPoints(64);
    const geometry = new THREE.BufferGeometry().setFromPoints(points);
    
    const material = new THREE.LineBasicMaterial({ 
        color: color,
        transparent: true,
        opacity: opacity,
        linewidth: 2
    });
    
    const ellipse = new THREE.Line(geometry, material);
    ellipse.rotation.x = Math.PI / 2; // Rotate to horizontal plane
    ellipse.position.y = height;
    ellipse.userData.isEllipse = true;
    
    scene.add(ellipse);
}

function drawSpokeLine(angle, ellipseData, isDark, height = 0) {
    // Calculate end point on outer ellipse
    const outerX = ellipseData.radiusX * Math.cos(angle) * 0.5;
    const outerZ = ellipseData.radiusY * Math.sin(angle) * 0.5;
    
    // Calculate start point at inner ellipse
    const innerX = ellipseData.innerRadiusX * Math.cos(angle) * 0.5;
    const innerZ = ellipseData.innerRadiusY * Math.sin(angle) * 0.5;
    
    const points = [];
    points.push(new THREE.Vector3(innerX, height, innerZ));
    points.push(new THREE.Vector3(outerX, height, outerZ));
    
    const geometry = new THREE.BufferGeometry().setFromPoints(points);
    const material = new THREE.LineBasicMaterial({ 
        color: isDark ? 0x90caf9 : 0x1565c0,
        transparent: true,
        opacity: 0.6,
        linewidth: 2
    });
    
    const line = new THREE.Line(geometry, material);
    line.userData.isSpoke = true;
    
    scene.add(line);
}

function render3D() {
    if (renderer && scene && camera) {
        renderer.render(scene, camera);
    }
}

function canResize() {
    let d = document.getElementById("canvas-container")
    let elHeight = d.clientHeight;
    let elWidth = d.clientWidth;
    
    if (is3DMode) {
        if (renderer) {
            renderer.setSize(elWidth, elHeight);
            camera.aspect = elWidth / elHeight;
            camera.updateProjectionMatrix();
            render3D();
        }
        return;
    }
    
    let width = elWidth
    let height = elHeight
    
    let h1 = height
    let w1 = height * ellipseWidth / ellipseHeight
    
    let w2 = width
    let h2 = width * ellipseHeight / ellipseWidth
    
    if (fitMode == 0) {
        if (w1 > w2) {
            width = w2
            height = h2
        } else {
            width = w1
            height = h1
        }
    } else if (fitMode == 1) {
            width = w2
            height = h2
    } else {
            width = w1
            height = h1
    }
    
    width *= scale[2];
    height *= scale[3];

    let can = document.getElementById("myCanvas");
    
    canWidth = width
    canHeight = height
    
    can.width = elWidth
    can.height = elHeight
        
    var c = document.getElementById("myCanvas");
    var ctx = c.getContext("2d");

    circle2(ctx)
}

// Control functions
function incX() {
    ellipseWidth++;
    document.getElementById("ellw").value = ellipseWidth;
    if (outerMirrored) {
        ellipseHeight = ellipseWidth;
        document.getElementById("ellh").value = ellipseHeight;
    }
    updateView();
}
function decX() {
    ellipseWidth--;
    if (ellipseWidth<3) ellipseWidth = 3;
    document.getElementById("ellw").value = ellipseWidth;
    if (outerMirrored) {
        ellipseHeight = ellipseWidth;
        document.getElementById("ellh").value = ellipseHeight;
    }
    updateView();
}
function incY() {
    ellipseHeight++;
    document.getElementById("ellh").value = ellipseHeight;
    if (outerMirrored) {
        ellipseWidth = ellipseHeight;
        document.getElementById("ellw").value = ellipseWidth;
    }
    updateView();
}
function decY() {
    ellipseHeight--;
    if (ellipseHeight<3) ellipseHeight = 3;
    document.getElementById("ellh").value = ellipseHeight;
    if (outerMirrored) {
        ellipseWidth = ellipseHeight;
        document.getElementById("ellw").value = ellipseWidth;
    }
    updateView();
}
function getX() {
    ellipseWidth = parseInt(document.getElementById("ellw").value) || 3;
    if (ellipseWidth<3) ellipseWidth = 3;
    document.getElementById("ellw").value = ellipseWidth;
    if (outerMirrored) {
        ellipseHeight = ellipseWidth;
        document.getElementById("ellh").value = ellipseHeight;
    }
    updateView();
}
function getY() {
    ellipseHeight = parseInt(document.getElementById("ellh").value) || 3;
    if (ellipseHeight<3) ellipseHeight = 3;
    document.getElementById("ellh").value = ellipseHeight;
    if (outerMirrored) {
        ellipseWidth = ellipseHeight;
        document.getElementById("ellw").value = ellipseWidth;
    }
    updateView();
}

function incInnerX() {
    innerEllipseWidth++;
    document.getElementById("innerellw").value = innerEllipseWidth;
    if (innerMirrored) {
        innerEllipseHeight = innerEllipseWidth;
        document.getElementById("innerellh").value = innerEllipseHeight;
    }
    updateView();
}
function decInnerX() {
    innerEllipseWidth--;
    if (innerEllipseWidth<1) innerEllipseWidth = 1;
    document.getElementById("innerellw").value = innerEllipseWidth;
    if (innerMirrored) {
        innerEllipseHeight = innerEllipseWidth;
        document.getElementById("innerellh").value = innerEllipseHeight;
    }
    updateView();
}
function incInnerY() {
    innerEllipseHeight++;
    document.getElementById("innerellh").value = innerEllipseHeight;
    if (innerMirrored) {
        innerEllipseWidth = innerEllipseHeight;
        document.getElementById("innerellw").value = innerEllipseWidth;
    }
    updateView();
}
function decInnerY() {
    innerEllipseHeight--;
    if (innerEllipseHeight<1) innerEllipseHeight = 1;
    document.getElementById("innerellh").value = innerEllipseHeight;
    if (innerMirrored) {
        innerEllipseWidth = innerEllipseHeight;
        document.getElementById("innerellw").value = innerEllipseWidth;
    }
    updateView();
}
function getInnerX() {
    innerEllipseWidth = parseInt(document.getElementById("innerellw").value)
    if (innerEllipseWidth<1) innerEllipseWidth = 1;
    document.getElementById("innerellw").value = innerEllipseWidth;
    if (innerMirrored) {
        innerEllipseHeight = innerEllipseWidth;
        document.getElementById("innerellh").value = innerEllipseHeight;
    }
    updateView();
}
function getInnerY() {
    innerEllipseHeight = parseInt(document.getElementById("innerellh").value)
    if (innerEllipseHeight<1) innerEllipseHeight = 1;
    document.getElementById("innerellh").value = innerEllipseHeight;
    if (innerMirrored) {
        innerEllipseWidth = innerEllipseHeight;
        document.getElementById("innerellw").value = innerEllipseWidth;
    }
    updateView();
}

function toggleOuterMirror() {
    outerMirrored = !outerMirrored;
    updateMirrorButton('outer-mirror', outerMirrored);
    
    if (outerMirrored) {
        ellipseHeight = ellipseWidth;
        document.getElementById("ellh").value = ellipseHeight;
        updateView();
    }
}

function toggleInnerMirror() {
    innerMirrored = !innerMirrored;
    updateMirrorButton('inner-mirror', innerMirrored);
    
    if (innerMirrored) {
        innerEllipseHeight = innerEllipseWidth;
        document.getElementById("innerellh").value = innerEllipseHeight;
        updateView();
    }
}

function updateMirrorButton(buttonId, mirrored) {
    const button = document.getElementById(buttonId);
    if (!button) return;
    
    const icon = button.querySelector('.material-icons');
    if (!icon) return;
    
    if (mirrored) {
        button.classList.add('mirrored');
        icon.textContent = 'sync';
        button.title = 'Width/Height mirrored (click to separate)';
    } else {
        button.classList.remove('mirrored');
        icon.textContent = 'sync_disabled';
        button.title = 'Width/Height separate (click to mirror)';
    }
}

function incSpokes() {
    totalSpokes++;
    if (totalSpokes > maxSpokes) totalSpokes = maxSpokes;
    document.getElementById("spokes").value = totalSpokes;
    updateView();
}

function decSpokes() {
    totalSpokes--;
    if (totalSpokes < 4) totalSpokes = 4;
    document.getElementById("spokes").value = totalSpokes;
    updateView();
}

function getSpokes() {
    totalSpokes = parseInt(document.getElementById("spokes").value);
    if (totalSpokes < 4) totalSpokes = 4;
    if (totalSpokes > maxSpokes) totalSpokes = maxSpokes;
    document.getElementById("spokes").value = totalSpokes;
    updateView();
}

function nextSpoke() {
    currentSpokeIndex++;
    updateView();
}

function prevSpoke() {
    currentSpokeIndex--;
    updateView();
}

// 3D Mode controls
function toggle3DMode() {
    is3DMode = !is3DMode;
    
    const canvas2D = document.getElementById('myCanvas');
    const scene3D = document.getElementById('scene3d');
    const toggleBtn = document.getElementById('view-toggle');
    const staircaseControls = document.getElementById('staircase-controls');
    
    if (is3DMode) {
        canvas2D.style.display = 'none';
        scene3D.style.display = 'block';
        toggleBtn.classList.add('active');
        toggleBtn.innerHTML = '<span class="material-icons">view_in_ar</span> 3D Mode';
        staircaseControls.style.display = 'block';
        
        if (!scene) {
            init3D();
        } else {
            generate3DStaircase();
            canResize();
        }
    } else {
        canvas2D.style.display = 'block';
        scene3D.style.display = 'none';
        toggleBtn.classList.remove('active');
        toggleBtn.innerHTML = '<span class="material-icons">grid_view</span> 2D Mode';
        staircaseControls.style.display = 'none';
        canResize();
    }
}

function updateView() {
    if (is3DMode) {
        generate3DStaircase();
    } else {
        canResize();
    }
}

function setDirection(direction) {
    staircaseDirection = direction;
    
    // Update button states
    document.querySelectorAll('.direction-btn').forEach(btn => {
        btn.classList.remove('active');
    });
    
    if (direction === 1) {
        document.getElementById('up-btn').classList.add('active');
    } else {
        document.getElementById('down-btn').classList.add('active');
    }
    
    if (is3DMode) {
        generate3DStaircase();
    }
}

function incStepHeight() {
    stepHeight += 0.5;
    if (stepHeight > 5) stepHeight = 5;
    document.getElementById("stepheight").value = stepHeight;
    if (is3DMode) generate3DStaircase();
}

function decStepHeight() {
    stepHeight -= 0.5;
    if (stepHeight < 0.5) stepHeight = 0.5;
    document.getElementById("stepheight").value = stepHeight;
    if (is3DMode) generate3DStaircase();
}

function getStepHeight() {
    stepHeight = parseFloat(document.getElementById("stepheight").value) || 1;
    if (stepHeight < 0.5) stepHeight = 0.5;
    if (stepHeight > 5) stepHeight = 5;
    document.getElementById("stepheight").value = stepHeight;
    if (is3DMode) generate3DStaircase();
}

function incRotations() {
    rotations += 0.5;
    if (rotations > 5) rotations = 5;
    document.getElementById("rotations").value = rotations;
    if (is3DMode) generate3DStaircase();
}

function decRotations() {
    rotations -= 0.5;
    if (rotations < 0.5) rotations = 0.5;
    document.getElementById("rotations").value = rotations;
    if (is3DMode) generate3DStaircase();
}

function getRotations() {
    rotations = parseFloat(document.getElementById("rotations").value) || 2;
    if (rotations < 0.5) rotations = 0.5;
    if (rotations > 5) rotations = 5;
    document.getElementById("rotations").value = rotations;
    if (is3DMode) generate3DStaircase();
}

function incStartSpoke() {
    startingSpoke++;
    if (startingSpoke >= totalSpokes) startingSpoke = 0;
    document.getElementById("startspoke").value = startingSpoke;
    if (is3DMode) generate3DStaircase();
}

function decStartSpoke() {
    startingSpoke--;
    if (startingSpoke < 0) startingSpoke = totalSpokes - 1;
    document.getElementById("startspoke").value = startingSpoke;
    if (is3DMode) generate3DStaircase();
}

function getStartSpoke() {
    startingSpoke = parseInt(document.getElementById("startspoke").value) || 0;
    if (startingSpoke < 0) startingSpoke = 0;
    if (startingSpoke >= totalSpokes) startingSpoke = totalSpokes - 1;
    document.getElementById("startspoke").value = startingSpoke;
    if (is3DMode) generate3DStaircase();
}

function initCanvas() {
    document.getElementById("ellw").value = ellipseWidth;
    document.getElementById("ellh").value = ellipseHeight;
    document.getElementById("innerellw").value = innerEllipseWidth;
    document.getElementById("innerellh").value = innerEllipseHeight;
    document.getElementById("spokes").value = totalSpokes;
    document.getElementById("stepheight").value = stepHeight;
    document.getElementById("rotations").value = rotations;
    document.getElementById("startspoke").value = startingSpoke;
    
    setTimeout(() => {
        updateMirrorButton('outer-mirror', outerMirrored);
        updateMirrorButton('inner-mirror', innerMirrored);
        setDirection(1); // Default to upward
    }, 0);
    
    initTheme();
    canResize();
}

function initTheme() {
    document.documentElement.setAttribute('data-theme', 'dark');
    updateThemeIcon('dark');
}

function toggleTheme() {
    const currentTheme = document.documentElement.getAttribute('data-theme') || 'dark';
    const newTheme = currentTheme === 'light' ? 'dark' : 'light';
    
    document.documentElement.setAttribute('data-theme', newTheme);
    updateThemeIcon(newTheme);
    
    // Update 3D scene background if in 3D mode
    if (is3DMode && scene) {
        const isDark = newTheme === 'dark';
        scene.background = new THREE.Color(isDark ? 0x141218 : 0xfefbff);
        generate3DStaircase(); // Regenerate with new colors
    }
    
    updateView();
}

function updateThemeIcon(theme) {
    const themeIcon = document.getElementById('theme-icon');
    if (themeIcon) {
        themeIcon.textContent = theme === 'light' ? 'dark_mode' : 'light_mode';
    }
}

function modeChange() {
    let e = document.getElementById("fitmode");
    fitMode = parseInt(e.options[e.selectedIndex].value);
    canResize();
}

function relMouseCoords(currentElement, event){
    var totalOffsetX = 0;
    var totalOffsetY = 0;
    var canvasX = 0;
    var canvasY = 0;
    var element = currentElement;

    do{
        totalOffsetX += element.offsetLeft - element.scrollLeft;
        totalOffsetY += element.offsetTop - element.scrollTop;
    }
    while(element = element.offsetParent)

    canvasX = event.pageX - totalOffsetX;
    canvasY = event.pageY - totalOffsetY;

    return {x:canvasX, y:canvasY}
}

function canvasMouseDown(event) {
    if (is3DMode) return; // Disable 2D mouse controls in 3D mode
    
    let can = document.getElementById("myCanvas");
    let coords = relMouseCoords(can, event)
    
    if (event.buttons!=null ? (event.buttons & 1) : (event.which==1)) {
        selection[0] = selection[2] = parseInt((coords.x - scale[0]) * ellipseWidth / canWidth);
        selection[1] = selection[3] = parseInt((coords.y - scale[1]) * ellipseHeight / canHeight);
    
        canResize();
        makingSelection = true;    
    } else if (event.buttons!=null ? (event.buttons & 2) : (event.which==3)) {
        if (scale[2] > 1 || fitMode!=0) {
            pan_data[0] = scale[0];
            pan_data[1] = scale[1];
            pan_data[2] = coords.x;
            pan_data[3] = coords.y;
            panning = true;
        } else {
            scale = [0, 0, 1, 1]
        }
        
        canResize();
    }
    
    return false;
}

function canvasMouseMove(event) {
    if (is3DMode) return;
    
    if (makingSelection) { 
        let can = document.getElementById("myCanvas");
        let coords = relMouseCoords(can, event)
        selection[2] = parseInt((coords.x - scale[0]) * ellipseWidth / canWidth);
        selection[3] = parseInt((coords.y - scale[1]) * ellipseHeight / canHeight);
    
        canResize();
    } else if (panning) {
        let can = document.getElementById("myCanvas");
        let coords = relMouseCoords(can, event)
        
        scale[0] = pan_data[0] + (coords.x - pan_data[2]);
        scale[1] = pan_data[1] + (coords.y - pan_data[3]);
        
        canResize();
    }

    return false;
}

function canvasMouseUp(event) {
    if (is3DMode) return;
    
    if (makingSelection) {
        let can = document.getElementById("myCanvas");
        let coords = relMouseCoords(can, event)
        selection[2] = parseInt((coords.x - scale[0]) * ellipseWidth / canWidth);
        selection[3] = parseInt((coords.y - scale[1]) * ellipseHeight / canHeight);
    
        canResize();
        makingSelection = false;
    } else if (panning) {
        let can = document.getElementById("myCanvas");
        let coords = relMouseCoords(can, event)
        
        scale[0] = pan_data[0] + (coords.x - pan_data[2]);
        scale[1] = pan_data[1] + (coords.y - pan_data[3]);
        
        canResize();
        panning = false;
    }

    return false;
}

function MouseWheelHandler(e) {
    if (is3DMode) return;
    
    let can = document.getElementById("myCanvas");
    let coords = relMouseCoords(can, e)
    
    let delta = e.wheelDelta ? e.wheelDelta : -e.detail;
    
    if (delta < 0) {
        scale[2] *= 0.5;
        scale[3] *= 0.5;
        scale[0] = coords.x - (coords.x - scale[0])*0.5;
        scale[1] = coords.y - (coords.y - scale[1])*0.5;
    } else {
        scale[2] *= 2;
        scale[3] *= 2;
        scale[0] = coords.x - (coords.x - scale[0])*2;
        scale[1] = coords.y - (coords.y - scale[1])*2;
    }
    
    if (scale[2] <= 1) {
        scale[2] = 1;
        scale[3] = 1;
        scale[0] = 0;
        scale[1] = 0;
    }
    
    canResize();

    return false;
}

</script>

</head>

<body onresize="canResize()" onload="initCanvas()">
    
<header class="top-app-bar">
    <h1>Ellipse & Staircase Generator</h1>
    <div class="header-controls">
        <button class="view-toggle" id="view-toggle" onclick="toggle3DMode()" title="Toggle 3D Mode">
            <span class="material-icons">grid_view</span> 2D Mode
        </button>
        <button class="theme-toggle" onclick="toggleTheme()" title="Toggle theme">
            <span class="material-icons" id="theme-icon">light_mode</span>
        </button>
    </div>
</header>

<div class="content">
    <div class="controls-panel">
        
        <!-- Outer Ellipse -->
        <div class="surface">
            <h2>Outer Ellipse</h2>
            <div class="control-group">
                <span class="label">Width</span>
                <button class="btn btn-filled" onclick="decX()">−</button>
                <input type="text" id="ellw" class="input-field" onkeyup="getX()">
                <button class="btn btn-filled" onclick="incX()">+</button>
                <button class="btn btn-mirror" id="outer-mirror" onclick="toggleOuterMirror()" title="Width/Height mirrored (click to separate)">
                    <span class="material-icons">sync</span>
                </button>
            </div>
            <div class="control-group">
                <span class="label">Height</span>
                <button class="btn btn-filled" onclick="decY()">−</button>
                <input type="text" id="ellh" class="input-field" onkeyup="getY()">
                <button class="btn btn-filled" onclick="incY()">+</button>
            </div>
        </div>

        <!-- Inner Ellipse -->
        <div class="surface">
            <h2>Inner Ellipse</h2>
            <div class="control-group">
                <span class="label">Width</span>
                <button class="btn btn-filled" onclick="decInnerX()">−</button>
                <input type="text" id="innerellw" class="input-field" onkeyup="getInnerX()">
                <button class="btn btn-filled" onclick="incInnerX()">+</button>
                <button class="btn btn-mirror" id="inner-mirror" onclick="toggleInnerMirror()" title="Width/Height mirrored (click to separate)">
                    <span class="material-icons">sync</span>
                </button>
            </div>
            <div class="control-group">
                <span class="label">Height</span>
                <button class="btn btn-filled" onclick="decInnerY()">−</button>
                <input type="text" id="innerellh" class="input-field" onkeyup="getInnerY()">
                <button class="btn btn-filled" onclick="incInnerY()">+</button>
            </div>
        </div>

        <!-- Spokes -->
        <div class="surface">
            <h2>Spokes</h2>
            <div class="control-group">
                <span class="label">Count</span>
                <button class="btn btn-filled" onclick="decSpokes()">−</button>
                <input type="text" id="spokes" class="input-field" onkeyup="getSpokes()">
                <button class="btn btn-filled" onclick="incSpokes()">+</button>
            </div>
            <div class="spoke-controls">
                <button class="btn btn-outlined" onclick="prevSpoke()">
                    <span class="material-icons">chevron_left</span>
                    Previous
                </button>
                <button class="btn btn-outlined" onclick="nextSpoke()">
                    Next
                    <span class="material-icons">chevron_right</span>
                </button>
            </div>
        </div>

        <!-- 3D Staircase Controls -->
        <div class="surface" id="staircase-controls" style="display: none;">
            <h2>3D Staircase</h2>
            
            <div class="control-group">
                <span class="label">Direction</span>
                <div class="direction-toggle">
                    <button class="direction-btn active" id="up-btn" onclick="setDirection(1)">
                        <span class="material-icons">arrow_upward</span>
                        Up
                    </button>
                    <button class="direction-btn" id="down-btn" onclick="setDirection(-1)">
                        <span class="material-icons">arrow_downward</span>
                        Down
                    </button>
                </div>
            </div>
            
            <div class="control-group">
                <span class="label">Step Height</span>
                <button class="btn btn-filled" onclick="decStepHeight()">−</button>
                <input type="text" id="stepheight" class="input-field" onkeyup="getStepHeight()">
                <button class="btn btn-filled" onclick="incStepHeight()">+</button>
            </div>
            
            <div class="control-group">
                <span class="label">Rotations</span>
                <button class="btn btn-filled" onclick="decRotations()">−</button>
                <input type="text" id="rotations" class="input-field" onkeyup="getRotations()">
                <button class="btn btn-filled" onclick="incRotations()">+</button>
            </div>
            
            <div class="control-group">
                <span class="label">Start Spoke</span>
                <button class="btn btn-filled" onclick="decStartSpoke()">−</button>
                <input type="text" id="startspoke" class="input-field" onkeyup="getStartSpoke()">
                <button class="btn btn-filled" onclick="incStartSpoke()">+</button>
            </div>
        </div>

        <!-- Display -->
        <div class="surface">
            <h2>Display</h2>
            <div class="control-group">
                <span class="label">Fit Mode</span>
                <div class="select">
                    <select id="fitmode" onchange="modeChange()">
                        <option value="0" selected>Fit to window</option>
                        <option value="1">Fit width</option>
                        <option value="2">Fit height</option>
                    </select>
                </div>
            </div>
        </div>

        <!-- Instructions -->
        <div class="instructions">
            <div class="instruction-row">
                <span class="material-icons">mouse</span>
                <span>2D: Click + drag to select</span>
            </div>
            <div class="instruction-row">
                <span class="material-icons">pan_tool</span>
                <span>2D: Right-click + drag to pan</span>
            </div>
            <div class="instruction-row">
                <span class="material-icons">zoom_in</span>
                <span>Mouse wheel to zoom</span>
            </div>
            <div class="instruction-row">
                <span class="material-icons">view_in_ar</span>
                <span>3D: Drag to rotate view</span>
            </div>
            <div class="instruction-row">
                <span class="material-icons">open_with</span>
                <span>3D: Shift+drag to pan camera</span>
            </div>
            <div class="instruction-row">
                <span class="material-icons">keyboard</span>
                <span>3D: WASD/Arrows to move, Q/E for up/down</span>
            </div>
        </div>

        <!-- Credits -->
        <div class="surface" style="font-size: 12px; padding: 12px;">
            <div style="color: var(--on-surface-variant); line-height: 1.4;">
                <div style="margin-bottom: 8px;">
                    <strong>Based on the original work by:</strong><br>
                    Timothy Miller, Binghamton University
                </div>
                <div>
                    <a href="https://www.cs.binghamton.edu/~millerti/circlegen.html" 
                       target="_blank" 
                       style="color: var(--primary); text-decoration: none;"
                       onmouseover="this.style.textDecoration='underline'"
                       onmouseout="this.style.textDecoration='none'">
                        View Original Version →
                    </a>
                </div>
            </div>
        </div>

    </div>

    <div class="canvas-container" id="canvas-container">
        <canvas id="myCanvas"></canvas>
        <div id="scene3d"></div>
    </div>
</div>

<script>
let can = document.getElementById("myCanvas");
can.addEventListener('mousedown', canvasMouseDown);
can.addEventListener('mousemove', canvasMouseMove);
can.addEventListener('mouseup', canvasMouseUp);
can.addEventListener('mouseleave', canvasMouseUp);
can.addEventListener("mousewheel", MouseWheelHandler, false);
can.addEventListener("DOMMouseScroll", MouseWheelHandler, false);
can.addEventListener('contextmenu', function(e) {
    e.preventDefault();
}, false);

initCanvas();
</script>

</body>
</html>
