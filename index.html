<!DOCTYPE HTML>
<html>
<head>
<title>Ellipse Ring Staircase Generator</title>
<link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">

<style>
* {
  box-sizing: border-box;
}

:root {
  --primary: #1565c0;
  --primary-hover: #1976d2;
  --primary-light: #bbdefb;
  --on-primary: #ffffff;
  --surface: #ffffff;
  --surface-variant: #f5f5f5;
  --on-surface: #1d1b20;
  --on-surface-variant: #49454f;
  --outline: #79747e;
  --outline-variant: #cac4d0;
  --background: #fefbff;
  --on-background: #1d1b20;
  --grid-color: #e7e0ec;
  --canvas-bg: #fefbff;
  --ellipse-outer: #d32f2f;
  --ellipse-inner: #1565c0;
  --block-color: #1d1b20;
  --instruction-bg: #fff8e1;
  --instruction-border: #f9cc33;
  --instruction-text: #614a00;
  --shadow: rgba(0, 0, 0, 0.12);
  --shadow-strong: rgba(0, 0, 0, 0.16);
}

[data-theme="dark"] {
  --primary: #90caf9;
  --primary-hover: #64b5f6;
  --primary-light: #1e3a8a;
  --on-primary: #003d82;
  --surface: #1d1b20;
  --surface-variant: #141218;
  --on-surface: #e6e0e9;
  --on-surface-variant: #cac4d0;
  --outline: #938f99;
  --outline-variant: #49454f;
  --background: #141218;
  --on-background: #e6e0e9;
  --grid-color: #49454f;
  --canvas-bg: #141218;
  --ellipse-outer: #f2b8b5;
  --ellipse-inner: #a8c7fa;
  --block-color: #e6e0e9;
  --instruction-bg: #3d2f00;
  --instruction-border: #6c5d00;
  --instruction-text: #ffd95a;
  --shadow: rgba(0, 0, 0, 0.3);
  --shadow-strong: rgba(0, 0, 0, 0.4);
}

html, body {
  margin: 0;
  padding: 0;
  font-family: 'Roboto', -apple-system, BlinkMacSystemFont, sans-serif;
  background-color: var(--background);
  color: var(--on-background);
  transition: background-color 0.3s ease, color 0.3s ease;
}

body {
  height: 100vh;
  display: flex;
  flex-direction: column;
}

.top-app-bar {
  background: var(--primary);
  color: var(--on-primary);
  padding: 16px 24px;
  box-shadow: 0px 2px 4px var(--shadow);
  display: flex;
  justify-content: space-between;
  align-items: center;
  transition: all 0.3s ease;
}

.top-app-bar h1 {
  margin: 0;
  font-size: 22px;
  font-weight: 400;
}

.header-controls {
  display: flex;
  gap: 8px;
  align-items: center;
}

.theme-toggle, .view-toggle {
  background: none;
  border: none;
  color: var(--on-primary);
  cursor: pointer;
  padding: 8px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: background-color 0.2s ease;
}

.theme-toggle:hover {
  background: rgba(255, 255, 255, 0.1);
}

.view-toggle {
  border-radius: 20px;
  padding: 8px 16px;
  gap: 8px;
  background: rgba(255, 255, 255, 0.1);
  border: 1px solid rgba(255, 255, 255, 0.2);
  font-size: 14px;
  font-weight: 500;
}

.view-toggle:hover {
  background: rgba(255, 255, 255, 0.2);
}

.view-toggle.active {
  background: var(--on-primary);
  color: var(--primary);
}

.material-icons {
  font-size: 24px;
}

.content {
  flex: 1;
  display: flex;
  gap: 16px;
  padding: 16px;
  overflow: hidden;
  transition: all 0.3s ease;
}

.controls-panel {
  width: 370px;
  display: flex;
  flex-direction: column;
  gap: 16px;
  overflow-y: auto;
  overflow-x: hidden;
  padding-right: 8px;
  transition: all 0.3s ease;
}

.controls-panel::-webkit-scrollbar {
  width: 8px;
}

.controls-panel::-webkit-scrollbar-track {
  background: var(--surface-variant);
  border-radius: 4px;
}

.controls-panel::-webkit-scrollbar-thumb {
  background: var(--outline);
  border-radius: 4px;
}

.surface {
  background: var(--surface);
  border-radius: 12px;
  padding: 16px;
  box-shadow: 0px 1px 3px var(--shadow);
  border: 1px solid var(--outline-variant);
  transition: background-color 0.3s ease, border-color 0.3s ease;
}

.surface h2 {
  margin: 0 0 16px 0;
  font-size: 16px;
  font-weight: 500;
  color: var(--primary);
}

.control-group {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 16px;
}

.control-group:last-child {
  margin-bottom: 0;
}

.label {
  font-size: 14px;
  color: var(--on-surface);
  font-weight: 400;
  min-width: 90px;
  flex-shrink: 0;
}

.input-field {
  width: 70px;
  height: 48px;
  border: 1px solid var(--outline);
  border-radius: 8px;
  padding: 0 12px;
  font-family: inherit;
  font-size: 16px;
  text-align: center;
  background: var(--surface);
  color: var(--on-surface);
  transition: border-color 0.2s ease, background-color 0.3s ease, color 0.3s ease;
}

.input-field:focus {
  outline: none;
  border-color: var(--primary);
  border-width: 2px;
  padding: 0 11px;
}

.btn {
  border: none;
  border-radius: 12px;
  padding: 12px 20px;
  font-family: inherit;
  font-weight: 500;
  font-size: 14px;
  cursor: pointer;
  transition: all 0.2s ease;
  min-width: 48px;
  height: 48px;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 4px;
}

.btn-filled {
  background: var(--primary);
  color: var(--on-primary);
}

.btn-filled:hover {
  background: var(--primary-hover);
  box-shadow: 0px 2px 4px var(--shadow-strong);
}

.btn-filled:active {
  box-shadow: 0px 1px 2px var(--shadow);
}

.btn-icon {
  background: transparent;
  border: 1px solid var(--outline);
  color: var(--on-surface-variant);
  min-width: 48px;
  width: 48px;
  height: 48px;
  padding: 0;
  transition: all 0.2s ease;
  border-radius: 12px;
}

.btn-icon.active {
  background: var(--primary-light);
  color: var(--primary);
  border-color: var(--primary);
}

.btn-icon:hover {
  background: var(--surface-variant);
  border-color: var(--on-surface);
}

.btn-icon.active:hover {
  background: var(--primary-light);
  opacity: 0.9;
}

.direction-toggle {
  display: flex;
  gap: 0;
  border: 1px solid var(--outline);
  border-radius: 20px;
  overflow: hidden;
  height: 40px;
}

.direction-btn {
  flex: 1;
  padding: 0 12px;
  border: none;
  border-right: 1px solid var(--outline);
  background: transparent;
  color: var(--on-surface);
  cursor: pointer;
  transition: all 0.2s ease;
  font-size: 14px;
  font-weight: 500;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 6px;
  min-width: 80px;
}

.direction-btn:last-child {
  border-right: none;
}

.direction-btn .material-icons {
  font-size: 18px;
}

.direction-btn:hover:not(.active) {
  background: var(--surface-variant);
}

.direction-btn.active {
  background: var(--primary-light);
  color: var(--primary);
  font-weight: 600;
}

.canvas-container {
  flex: 1;
  background: var(--surface);
  border-radius: 12px;
  box-shadow: 0px 1px 3px var(--shadow);
  border: 1px solid var(--outline-variant);
  overflow: hidden;
  position: relative;
  transition: background-color 0.3s ease, border-color 0.3s ease;
}

#scene3d {
  display: block;
  width: 100%;
  height: 100%;
}

.instructions {
  background: var(--instruction-bg);
  border: 1px solid var(--instruction-border);
  border-radius: 8px;
  padding: 12px;
  font-size: 13px;
  color: var(--instruction-text);
  transition: background-color 0.3s ease, border-color 0.3s ease, color 0.3s ease;
}

.instruction-row {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 4px;
}

.instruction-row:last-child {
  margin-bottom: 0;
}

.instruction-row .material-icons {
  font-size: 16px;
}

.builder-overlay {
  position: absolute;
  top: 20px;
  left: 50%;
  transform: translateX(-50%);
  background: var(--surface);
  border: 2px solid var(--primary);
  border-radius: 16px;
  padding: 20px 40px;
  box-shadow: 0 4px 12px var(--shadow-strong);
  text-align: center;
  z-index: 10;
  pointer-events: none;
}

.builder-overlay h2 {
  margin: 0;
  font-size: 32px;
  color: var(--primary);
}

.builder-overlay p {
  margin: 4px 0 0 0;
  font-size: 14px;
  color: var(--on-surface-variant);
}

.builder-controls {
  position: absolute;
  bottom: 20px;
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  gap: 12px;
  z-index: 10;
}

.builder-info {
  position: absolute;
  top: 20px;
  right: 20px;
  background: var(--surface);
  border: 1px solid var(--outline-variant);
  border-radius: 12px;
  padding: 16px;
  box-shadow: 0 2px 8px var(--shadow);
  font-size: 13px;
  color: var(--on-surface);
  line-height: 1.6;
  z-index: 10;
  pointer-events: none;
}
</style>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
const CONSTANTS = {
  BLOCK_SIZE: 0.5,
  MIN_ELLIPSE_SIZE: 3,
  MIN_INNER_SIZE: 1,
  MIN_HEIGHT: 4,
  MAX_HEIGHT: 100,
  MIN_ROTATION: 45,
  MAX_ROTATION: 720,
  MIN_STARTING_ANGLE: 0,
  MAX_STARTING_ANGLE: 315,
  CAMERA_MOVE_SPEED: 0.2,
  OPACITY: {
    INNER_RING: 0.15,
    ELLIPSE_OUTLINE: 0.3,
    EDGE: 0.5
  }
};

const state = {
  ellipse: {
    width: 40,
    height: 40,
    innerWidth: 20,
    innerHeight: 20,
    outerMirrored: true,
    innerMirrored: true
  },
  staircase: {
    currentStep: 0,
    totalHeight: 20,
    rotationDegrees: 360,
    verticalDirection: 1,
    rotationDirection: 1,
    showSingleStep: false,
    startingAngle: 0
  },
  canvas: {
    width: 100,
    height: 100,
    scale: [0, 0, 1, 1]
  },
  viewMode: '3d',
  builderMode: false,
  view3D: {
    scene: null,
    camera: null,
    renderer: null,
    cameraTarget: null,
    keys: {},
    needsRender: false,
    animationId: null
  }
};

const utils = {
  isDarkTheme() {
    return document.documentElement.getAttribute('data-theme') === 'dark';
  },

  clamp(value, min, max) {
    return Math.max(min, Math.min(max, value));
  },

  inside(x, y, cx, cy, rx, ry) {
    if (rx <= 0 || ry <= 0) return false;
    const ny = (y - cy) / ry;
    const nx = (x - cx) / rx;
    return (nx * nx + ny * ny < 1);
  },

  through(x, y, cx, cy, rx, ry) {
    let count = 0;
    count += this.inside(x - 0.5, y - 0.5, cx, cy, rx, ry) ? 1 : 0;
    count += this.inside(x + 0.5, y - 0.5, cx, cy, rx, ry) ? 1 : 0;
    count += this.inside(x - 0.5, y + 0.5, cx, cy, rx, ry) ? 1 : 0;
    count += this.inside(x + 0.5, y + 0.5, cx, cy, rx, ry) ? 1 : 0;
    return (count !== 0) && (count !== 4);
  },

  normalizeAngle(a) {
    let angle = a % (2 * Math.PI);
    return angle < 0 ? angle + 2 * Math.PI : angle;
  }
};

const controls = {
  adjustValue(config, delta) {
    const element = document.getElementById(config.id);
    let value = config.getter() + delta;
    value = utils.clamp(value, config.min, config.max);
    
    if (config.snap) {
      value = Math.round(value / config.snap) * config.snap;
    }
    
    config.setter(value);
    element.value = value;
    
    if (config.mirrorId && config.mirrorGetter()) {
      const mirrorElement = document.getElementById(config.mirrorId);
      config.mirrorSetter(value);
      mirrorElement.value = value;
    }
    
    this.updateView();
  },

  getValue(config) {
    const element = document.getElementById(config.id);
    let value = parseFloat(element.value);
    
    if (isNaN(value) || value < config.min) {
      value = config.min;
    } else if (value > config.max) {
      value = config.max;
    }
    
    if (config.snap) {
      value = Math.round(value / config.snap) * config.snap;
    }
    
    config.setter(value);
    element.value = value;
    
    if (config.mirrorId && config.mirrorGetter()) {
      const mirrorElement = document.getElementById(config.mirrorId);
      config.mirrorSetter(value);
      mirrorElement.value = value;
    }
    
    this.updateView();
  },

  updateView() {
    if (state.viewMode === '3d') {
      render3D.generateStaircase();
    } else {
      resizeCanvas();
    }
  },

  updateMirrorButton(buttonId, mirrored) {
    const button = document.getElementById(buttonId);
    if (!button) return;
    
    const icon = button.querySelector('.material-icons');
    if (!icon) return;
    
    if (mirrored) {
      button.classList.add('active');
      icon.textContent = 'sync';
      button.title = 'Mirrored (click to separate)';
    } else {
      button.classList.remove('active');
      icon.textContent = 'sync_disabled';
      button.title = 'Separate (click to mirror)';
    }
  }
};

const controlConfigs = {
  outerWidth: {
    id: 'ellw',
    getter: () => state.ellipse.width,
    setter: (v) => state.ellipse.width = v,
    mirrorId: 'ellh',
    mirrorGetter: () => state.ellipse.outerMirrored,
    mirrorSetter: (v) => state.ellipse.height = v,
    min: CONSTANTS.MIN_ELLIPSE_SIZE,
    max: Infinity
  },
  outerHeight: {
    id: 'ellh',
    getter: () => state.ellipse.height,
    setter: (v) => state.ellipse.height = v,
    mirrorId: 'ellw',
    mirrorGetter: () => state.ellipse.outerMirrored,
    mirrorSetter: (v) => state.ellipse.width = v,
    min: CONSTANTS.MIN_ELLIPSE_SIZE,
    max: Infinity
  },
  innerWidth: {
    id: 'innerellw',
    getter: () => state.ellipse.innerWidth,
    setter: (v) => state.ellipse.innerWidth = v,
    mirrorId: 'innerellh',
    mirrorGetter: () => state.ellipse.innerMirrored,
    mirrorSetter: (v) => state.ellipse.innerHeight = v,
    min: CONSTANTS.MIN_INNER_SIZE,
    max: Infinity
  },
  innerHeight: {
    id: 'innerellh',
    getter: () => state.ellipse.innerHeight,
    setter: (v) => state.ellipse.innerHeight = v,
    mirrorId: 'innerellw',
    mirrorGetter: () => state.ellipse.innerMirrored,
    mirrorSetter: (v) => state.ellipse.innerWidth = v,
    min: CONSTANTS.MIN_INNER_SIZE,
    max: Infinity
  },
  totalHeight: {
    id: 'totalheight',
    getter: () => state.staircase.totalHeight,
    setter: (v) => state.staircase.totalHeight = v,
    min: CONSTANTS.MIN_HEIGHT,
    max: CONSTANTS.MAX_HEIGHT
  },
  rotation: {
    id: 'rotation',
    getter: () => state.staircase.rotationDegrees,
    setter: (v) => state.staircase.rotationDegrees = v,
    min: CONSTANTS.MIN_ROTATION,
    max: CONSTANTS.MAX_ROTATION,
    snap: 45
  },
  startAngle: {
    id: 'startangle',
    getter: () => state.staircase.startingAngle,
    setter: (v) => state.staircase.startingAngle = v,
    min: CONSTANTS.MIN_STARTING_ANGLE,
    max: CONSTANTS.MAX_STARTING_ANGLE,
    snap: 45
  }
};

const render2D = {
  paintGrid(ctx) {
    ctx.beginPath();
    ctx.strokeStyle = getComputedStyle(document.documentElement)
      .getPropertyValue('--grid-color').trim();
    ctx.lineWidth = 1;
    
    const { width, height } = state.ellipse;
    const { width: canWidth, height: canHeight, scale } = state.canvas;
    
    for (let i = 0; i <= width; i++) {
      let x = (i * canWidth) / width;
      if (x >= canWidth) x = canWidth - 1;
      ctx.moveTo(x + 0.5 + scale[0], scale[1]);
      ctx.lineTo(x + 0.5 + scale[0], canHeight + scale[1]);
    }
    
    for (let i = 0; i <= height; i++) {
      let y = (i * canHeight) / height;
      if (y >= canHeight) y = canHeight - 1;
      ctx.moveTo(scale[0], y + 0.5 + scale[1]);
      ctx.lineTo(canWidth + scale[0], y + 0.5 + scale[1]);
    }
    
    ctx.stroke();
  },

  drawBlock(ctx, x, y) {
    const { width, height } = state.ellipse;
    const { width: canWidth, height: canHeight, scale } = state.canvas;
    
    const x1 = (x * canWidth) / width;
    const y1 = (y * canHeight) / height;
    const x2 = ((x + 1) * canWidth) / width;
    const y2 = ((y + 1) * canHeight) / height;
    const w = x2 - x1 + 0.75;
    const h = y2 - y1 + 0.75;
    
    ctx.fillRect(x1 + scale[0], y1 + scale[1], w, h);
  },

  getStepData(stepIndex) {
    const { width: ew, height: eh, innerWidth: inner_ew, innerHeight: inner_eh } = state.ellipse;
    const { startingAngle, totalHeight, rotationDegrees, rotationDirection } = state.staircase;
    
    const cx = ew / 2.0 - 0.5;
    const cy = eh / 2.0 - 0.5;
    const rx = ew / 2.0;
    const ry = eh / 2.0;
    const inner_rx = inner_ew / 2.0;
    const inner_ry = inner_eh / 2.0;
    
    const arr_final = Array.from({ length: eh }, () => Array(ew).fill(false));
    
    for (let j = 0; j < eh; j++) {
      for (let i = 0; i < ew; i++) {
        if (utils.through(i, j, cx, cy, rx, ry)) {
          arr_final[j][i] = true;
        }
      }
    }
    
    const stepAngleDegrees = rotationDegrees / totalHeight;
    const angleStep = (stepAngleDegrees * Math.PI) / 180;
    const startingAngleRadians = (startingAngle * Math.PI) / 180;
    
    let startAngle, endAngle;
    if (rotationDirection === 1) {
      startAngle = stepIndex * angleStep + startingAngleRadians;
      endAngle = startAngle + angleStep;
    } else {
      startAngle = startingAngleRadians - stepIndex * angleStep;
      endAngle = startAngle - angleStep;
    }
    
    let normStart = utils.normalizeAngle(startAngle);
    let normEnd = utils.normalizeAngle(endAngle);
    
    // Swap for clockwise rotation to get correct wedge
    if (rotationDirection === -1) {
      [normStart, normEnd] = [normEnd, normStart];
    }
    
    for (let j = 0; j < eh; j++) {
      for (let i = 0; i < ew; i++) {
        const dx = i - cx;
        const dy = j - cy;
        const angle = Math.atan2(dy, dx);
        const normalizedAngle = angle < 0 ? angle + 2 * Math.PI : angle;
        
        let inAngleRange = false;
        if (normStart <= normEnd) {
          inAngleRange = normalizedAngle >= normStart && normalizedAngle <= normEnd;
        } else {
          inAngleRange = normalizedAngle >= normStart || normalizedAngle <= normEnd;
        }
        
        const inRing = !utils.inside(i, j, cx, cy, inner_rx, inner_ry) && 
                       utils.inside(i, j, cx, cy, rx, ry);
        
        if (inAngleRange && inRing) {
          arr_final[j][i] = true;
        }
      }
    }

    return {
      data: arr_final,
      width: ew,
      height: eh,
      centerX: cx,
      centerY: cy,
      radiusX: rx,
      radiusY: ry,
      innerRadiusX: inner_rx,
      innerRadiusY: inner_ry
    };
  },

  draw(ctx) {
    const stepData = this.getStepData(state.staircase.currentStep);
    const { data: arr_final, width: ew, height: eh } = stepData;
    const rootStyles = getComputedStyle(document.documentElement);
    
    const colors = {
      canvasBg: rootStyles.getPropertyValue('--canvas-bg').trim(),
      blockColor: rootStyles.getPropertyValue('--block-color').trim(),
      ellipseOuter: rootStyles.getPropertyValue('--ellipse-outer').trim(),
      ellipseInner: rootStyles.getPropertyValue('--ellipse-inner').trim()
    };

    const { width: canWidth, height: canHeight, scale } = state.canvas;

    ctx.fillStyle = colors.canvasBg;
    ctx.fillRect(scale[0], scale[1], canWidth, canHeight);
    
    ctx.fillStyle = colors.blockColor;
    for (let j = 0; j < eh; j++) {
      for (let i = 0; i < ew; i++) {
        if (arr_final[j] && arr_final[j][i]) {
          this.drawBlock(ctx, i, j);
        }
      }
    }
    
    const scaleX = canWidth / ew;
    const scaleY = canHeight / eh;
    
    ctx.beginPath();
    ctx.strokeStyle = colors.ellipseOuter;
    ctx.lineWidth = 2;
    ctx.ellipse(
      (stepData.centerX + 0.5) * scaleX + scale[0],
      (stepData.centerY + 0.5) * scaleY + scale[1],
      stepData.radiusX * scaleX,
      stepData.radiusY * scaleY,
      0, 0, 2 * Math.PI
    );
    ctx.stroke();

    ctx.beginPath();
    ctx.strokeStyle = colors.ellipseInner;
    ctx.lineWidth = 2;
    ctx.ellipse(
      (stepData.centerX + 0.5) * scaleX + scale[0],
      (stepData.centerY + 0.5) * scaleY + scale[1],
      stepData.innerRadiusX * scaleX,
      stepData.innerRadiusY * scaleY,
      0, 0, 2 * Math.PI
    );
    ctx.stroke();

    this.paintGrid(ctx);
  }
};

const render3D = {
  init() {
    try {
      const container = document.getElementById('scene3d');
      const rect = container.getBoundingClientRect();
      
      state.view3D.scene = new THREE.Scene();
      state.view3D.scene.background = new THREE.Color(utils.isDarkTheme() ? 0x141218 : 0xfefbff);
      
      state.view3D.camera = new THREE.PerspectiveCamera(75, rect.width / rect.height, 0.1, 1000);
      state.view3D.camera.position.set(25, 20, 25);
      
      state.view3D.cameraTarget = new THREE.Vector3(0, 0, 0);
      state.view3D.camera.lookAt(state.view3D.cameraTarget);
      
      state.view3D.renderer = new THREE.WebGLRenderer({ antialias: true });
      state.view3D.renderer.setSize(rect.width, rect.height);
      state.view3D.renderer.shadowMap.enabled = false;
      
      container.appendChild(state.view3D.renderer.domElement);
      
      this.setupLighting();
      this.setupControls(container);
      this.startAnimationLoop();
      this.generateStaircase();
    } catch (error) {
      console.error('Failed to initialize 3D mode:', error);
      alert('3D visualization failed to initialize.');
    }
  },

  setupLighting() {
    const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
    state.view3D.scene.add(ambientLight);
    
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.7);
    directionalLight.position.set(50, 50, 25);
    state.view3D.scene.add(directionalLight);
  },

  setupControls(container) {
    let mouseDown = false;
    let mouseX = 0;
    let mouseY = 0;
    
    const handleMouseDown = (e) => {
      mouseDown = true;
      mouseX = e.clientX;
      mouseY = e.clientY;
    };
    
    const handleMouseMove = (e) => {
      if (!mouseDown) return;
      
      const deltaX = e.clientX - mouseX;
      const deltaY = e.clientY - mouseY;
      const { camera, cameraTarget } = state.view3D;
      
      if (e.shiftKey) {
        const right = new THREE.Vector3();
        const up = new THREE.Vector3(0, 1, 0);
        camera.getWorldDirection(right);
        right.cross(up).normalize();
        
        const panSpeed = 0.05;
        const panX = right.clone().multiplyScalar(-deltaX * panSpeed);
        const panY = up.clone().multiplyScalar(deltaY * panSpeed);
        
        camera.position.add(panX).add(panY);
        cameraTarget.add(panX).add(panY);
      } else {
        const offset = new THREE.Vector3().subVectors(camera.position, cameraTarget);
        const spherical = new THREE.Spherical().setFromVector3(offset);
        
        spherical.theta -= deltaX * 0.01;
        spherical.phi += deltaY * 0.01;
        spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi));
        
        offset.setFromSpherical(spherical);
        camera.position.copy(cameraTarget).add(offset);
      }
      
      camera.lookAt(cameraTarget);
      mouseX = e.clientX;
      mouseY = e.clientY;
      state.view3D.needsRender = true;
    };
    
    const handleMouseUp = () => {
      mouseDown = false;
    };
    
    const handleWheel = (e) => {
      e.preventDefault();
      const { camera, cameraTarget } = state.view3D;
      const offset = new THREE.Vector3().subVectors(camera.position, cameraTarget);
      const distance = offset.length();
      const newDistance = utils.clamp(distance + e.deltaY * 0.01, 5, 100);
      
      offset.normalize().multiplyScalar(newDistance);
      camera.position.copy(cameraTarget).add(offset);
      camera.lookAt(cameraTarget);
      state.view3D.needsRender = true;
    };
    
    container.addEventListener('mousedown', handleMouseDown);
    container.addEventListener('mousemove', handleMouseMove);
    container.addEventListener('mouseup', handleMouseUp);
    container.addEventListener('wheel', handleWheel, { passive: false });
  },

  startAnimationLoop() {
    const animate = () => {
      state.view3D.animationId = requestAnimationFrame(animate);
      
      const { camera, cameraTarget, keys } = state.view3D;
      let moved = false;
      const forward = new THREE.Vector3();
      const right = new THREE.Vector3();
      
      camera.getWorldDirection(forward);
      forward.y = 0;
      forward.normalize();
      
      right.crossVectors(forward, new THREE.Vector3(0, 1, 0)).normalize();
      
      if (keys['w'] || keys['arrowup']) {
        camera.position.addScaledVector(forward, CONSTANTS.CAMERA_MOVE_SPEED);
        cameraTarget.addScaledVector(forward, CONSTANTS.CAMERA_MOVE_SPEED);
        moved = true;
      }
      if (keys['s'] || keys['arrowdown']) {
        camera.position.addScaledVector(forward, -CONSTANTS.CAMERA_MOVE_SPEED);
        cameraTarget.addScaledVector(forward, -CONSTANTS.CAMERA_MOVE_SPEED);
        moved = true;
      }
      if (keys['a'] || keys['arrowleft']) {
        camera.position.addScaledVector(right, -CONSTANTS.CAMERA_MOVE_SPEED);
        cameraTarget.addScaledVector(right, -CONSTANTS.CAMERA_MOVE_SPEED);
        moved = true;
      }
      if (keys['d'] || keys['arrowright']) {
        camera.position.addScaledVector(right, CONSTANTS.CAMERA_MOVE_SPEED);
        cameraTarget.addScaledVector(right, CONSTANTS.CAMERA_MOVE_SPEED);
        moved = true;
      }
      if (keys['q']) {
        camera.position.y += CONSTANTS.CAMERA_MOVE_SPEED;
        cameraTarget.y += CONSTANTS.CAMERA_MOVE_SPEED;
        moved = true;
      }
      if (keys['e']) {
        camera.position.y -= CONSTANTS.CAMERA_MOVE_SPEED;
        cameraTarget.y -= CONSTANTS.CAMERA_MOVE_SPEED;
        moved = true;
      }
      
      if (moved) {
        camera.lookAt(cameraTarget);
        state.view3D.needsRender = true;
      }
      
      if (state.view3D.needsRender) {
        this.render();
        state.view3D.needsRender = false;
      }
    };
    
    animate();
  },

  cleanup() {
    if (state.view3D.animationId) {
      cancelAnimationFrame(state.view3D.animationId);
      state.view3D.animationId = null;
    }
    
    if (state.view3D.renderer) {
      state.view3D.renderer.dispose();
      const container = document.getElementById('scene3d');
      if (container && state.view3D.renderer.domElement.parentNode === container) {
        container.removeChild(state.view3D.renderer.domElement);
      }
    }
    
    if (state.view3D.scene) {
      state.view3D.scene.traverse((object) => {
        if (object.geometry) object.geometry.dispose();
        if (object.material) {
          if (Array.isArray(object.material)) {
            object.material.forEach(mat => mat.dispose());
          } else {
            object.material.dispose();
          }
        }
      });
    }
    
    state.view3D.scene = null;
    state.view3D.camera = null;
    state.view3D.renderer = null;
  },

  render() {
    const { renderer, scene, camera } = state.view3D;
    if (renderer && scene && camera) {
      renderer.render(scene, camera);
    }
  },

  updateTheme() {
    if (state.view3D.scene) {
      state.view3D.scene.background = new THREE.Color(utils.isDarkTheme() ? 0x141218 : 0xfefbff);
      
      const isDark = utils.isDarkTheme();
      state.view3D.scene.traverse((object) => {
        if (object.isMesh || object.isLine) {
          if (object.userData.isBlock && object.material) {
            if (object.material.color) {
              object.material.color.setHex(isDark ? 0xe6e0e9 : 0x1d1b20);
            }
          } else if (object.userData.isEllipse && object.material) {
            const isOuter = object.userData.ellipseType === 'outer';
            object.material.color.setHex(
              isOuter 
                ? (isDark ? 0xf2b8b5 : 0xd32f2f)
                : (isDark ? 0xa8c7fa : 0x1565c0)
            );
          }
        }
      });
      
      state.view3D.needsRender = true;
    }
  },

  generateStaircase() {
    if (!state.view3D.scene) return;
    
    const existingObjects = state.view3D.scene.children.filter(child => 
      child.userData.isBlock || child.userData.isEllipse
    );
    existingObjects.forEach(obj => {
      if (obj.geometry) obj.geometry.dispose();
      if (obj.material) obj.material.dispose();
      state.view3D.scene.remove(obj);
    });
    
    const { width: ew, height: eh, innerWidth: inner_ew, innerHeight: inner_eh } = state.ellipse;
    const { totalHeight, rotationDegrees, verticalDirection, rotationDirection, currentStep, showSingleStep, startingAngle } = state.staircase;
    
    const cx = ew / 2.0 - 0.5;
    const cy = eh / 2.0 - 0.5;
    const rx = ew / 2.0;
    const ry = eh / 2.0;
    const inner_rx = inner_ew / 2.0;
    const inner_ry = inner_eh / 2.0;
    
    const isDark = utils.isDarkTheme();
    const blockMaterial = new THREE.MeshLambertMaterial({ 
      color: isDark ? 0xe6e0e9 : 0x1d1b20 
    });
    
    const stepAngleDegrees = rotationDegrees / totalHeight;
    const angleStep = (stepAngleDegrees * Math.PI) / 180;
    const startingAngleRadians = (startingAngle * Math.PI) / 180;
    
    const stepStart = showSingleStep ? currentStep : 0;
    const stepEnd = showSingleStep ? currentStep + 1 : totalHeight;
    const stepHeight = 0.5;
    
    const allPositions = [];
    
    for (let i = stepStart; i < stepEnd; i++) {
      const stepIndex = i % totalHeight;
      
      let startAngle, endAngle;
      if (rotationDirection === 1) {
        startAngle = stepIndex * angleStep + startingAngleRadians;
        endAngle = startAngle + angleStep;
      } else {
        startAngle = startingAngleRadians - stepIndex * angleStep;
        endAngle = startAngle - angleStep;
      }
      
      const y = i * stepHeight * verticalDirection;
      
      const stepPositions = this.getStepPositions(cx, cy, rx, ry, inner_rx, inner_ry, 
                                                   ew, eh, startAngle, endAngle, y);
      allPositions.push(...stepPositions);
    }
    
    if (allPositions.length > 0) {
      const boxGeometry = new THREE.BoxGeometry(CONSTANTS.BLOCK_SIZE, CONSTANTS.BLOCK_SIZE, CONSTANTS.BLOCK_SIZE);
      const matrix = new THREE.Matrix4();
      this.createInstancedMesh(boxGeometry, blockMaterial, allPositions, matrix, true);
    }
    
    this.drawEllipseRing(rx * 0.5, ry * 0.5, 0, 
      isDark ? 0xf2b8b5 : 0xd32f2f, CONSTANTS.OPACITY.ELLIPSE_OUTLINE, 'outer');
    this.drawEllipseRing(inner_rx * 0.5, inner_ry * 0.5, 0, 
      isDark ? 0xa8c7fa : 0x1565c0, CONSTANTS.OPACITY.ELLIPSE_OUTLINE, 'inner');
    
    if (!showSingleStep) {
      const topY = (stepEnd - stepStart) * stepHeight * verticalDirection;
      this.drawEllipseRing(rx * 0.5, ry * 0.5, topY, 
        isDark ? 0xf2b8b5 : 0xd32f2f, CONSTANTS.OPACITY.ELLIPSE_OUTLINE, 'outer');
      this.drawEllipseRing(inner_rx * 0.5, inner_ry * 0.5, topY, 
        isDark ? 0xa8c7fa : 0x1565c0, CONSTANTS.OPACITY.ELLIPSE_OUTLINE, 'inner');
    }
    
    state.view3D.needsRender = true;
  },

  getStepPositions(cx, cy, rx, ry, inner_rx, inner_ry, ew, eh, startAngle, endAngle, height) {
    let normStart = utils.normalizeAngle(startAngle);
    let normEnd = utils.normalizeAngle(endAngle);
    
    // Swap for clockwise rotation to get correct wedge
    const rotationDirection = state.staircase.rotationDirection;
    if (rotationDirection === -1) {
      [normStart, normEnd] = [normEnd, normStart];
    }
    
    const scaleX = (rx * 2 * 0.5) / ew;
    const scaleZ = (ry * 2 * 0.5) / eh;
    
    const positions = [];
    
    for (let j = 0; j < eh; j++) {
      for (let i = 0; i < ew; i++) {
        const dx = i - cx;
        const dy = j - cy;
        const angle = Math.atan2(dy, dx);
        const normalizedAngle = utils.normalizeAngle(angle);
        
        const inAngleRange = (normStart <= normEnd) 
          ? (normalizedAngle >= normStart && normalizedAngle <= normEnd)
          : (normalizedAngle >= normStart || normalizedAngle <= normEnd);
        
        const inRing = !utils.inside(i, j, cx, cy, inner_rx, inner_ry) && 
                       utils.inside(i, j, cx, cy, rx, ry);
        
        if (inAngleRange && inRing) {
          const x = (i - cx) * scaleX;
          const z = (j - cy) * scaleZ;
          positions.push({ x, y: height, z });
        }
      }
    }
    
    return positions;
  },

  createInstancedMesh(geometry, material, positions, matrix, withEdges) {
    if (positions.length === 0) return;
    
    const mesh = new THREE.InstancedMesh(geometry, material, positions.length);
    positions.forEach((pos, i) => {
      matrix.setPosition(pos.x, pos.y, pos.z);
      mesh.setMatrixAt(i, matrix);
    });
    
    mesh.castShadow = false;
    mesh.receiveShadow = false;
    
    if (withEdges) {
      const edgeGeometry = new THREE.EdgesGeometry(geometry);
      const edgeMaterial = new THREE.LineBasicMaterial({ 
        color: utils.isDarkTheme() ? 0x49454f : 0xcac4d0,
        transparent: true,
        opacity: CONSTANTS.OPACITY.EDGE
      });
      const edgesMesh = new THREE.InstancedMesh(edgeGeometry, edgeMaterial, positions.length);
      positions.forEach((pos, i) => {
        matrix.setPosition(pos.x, pos.y, pos.z);
        edgesMesh.setMatrixAt(i, matrix);
      });
      edgesMesh.userData.isBlock = true;
      state.view3D.scene.add(edgesMesh);
    }
    
    mesh.userData.isBlock = true;
    state.view3D.scene.add(mesh);
  },

  drawEllipseRing(radiusX, radiusY, height, color, opacity, type) {
    const curve = new THREE.EllipseCurve(0, 0, radiusX, radiusY, 0, 2 * Math.PI, false, 0);
    const points = curve.getPoints(64);
    const geometry = new THREE.BufferGeometry().setFromPoints(points);
    const material = new THREE.LineBasicMaterial({ 
      color: color,
      transparent: true,
      opacity: opacity
    });
    
    const ellipse = new THREE.Line(geometry, material);
    ellipse.rotation.x = Math.PI / 2;
    ellipse.position.y = height;
    ellipse.userData.isEllipse = true;
    ellipse.userData.ellipseType = type;
    
    state.view3D.scene.add(ellipse);
  }
};

const keyHandlers = {
  init() {
    window.addEventListener('keydown', this.handleKeyDown);
    window.addEventListener('keyup', this.handleKeyUp);
  },
  
  cleanup() {
    window.removeEventListener('keydown', this.handleKeyDown);
    window.removeEventListener('keyup', this.handleKeyUp);
  },
  
  handleKeyDown(e) {
    if (state.builderMode && e.key === 'Escape') {
      toggleBuilderMode();
      return;
    }
    
    if (state.builderMode) {
      if (e.key === 'ArrowRight' || e.key === 'ArrowDown') {
        e.preventDefault();
        nextStep();
      } else if (e.key === 'ArrowLeft' || e.key === 'ArrowUp') {
        e.preventDefault();
        prevStep();
      }
    }
    
    if (state.viewMode === '3d') {
      state.view3D.keys[e.key.toLowerCase()] = true;
    }
  },
  
  handleKeyUp(e) {
    if (state.viewMode === '3d') {
      state.view3D.keys[e.key.toLowerCase()] = false;
    }
  }
};

function toggleOuterMirror() {
  state.ellipse.outerMirrored = !state.ellipse.outerMirrored;
  controls.updateMirrorButton('outer-mirror', state.ellipse.outerMirrored);
  if (state.ellipse.outerMirrored) {
    state.ellipse.height = state.ellipse.width;
    document.getElementById('ellh').value = state.ellipse.height;
    controls.updateView();
  }
}

function toggleInnerMirror() {
  state.ellipse.innerMirrored = !state.ellipse.innerMirrored;
  controls.updateMirrorButton('inner-mirror', state.ellipse.innerMirrored);
  if (state.ellipse.innerMirrored) {
    state.ellipse.innerHeight = state.ellipse.innerWidth;
    document.getElementById('innerellh').value = state.ellipse.innerHeight;
    controls.updateView();
  }
}

function setVerticalDirection(direction) {
  state.staircase.verticalDirection = direction;
  document.querySelectorAll('.direction-btn.vertical').forEach(btn => btn.classList.remove('active'));
  event.target.closest('.direction-btn').classList.add('active');
  controls.updateView();
}

function setRotationDirection(direction) {
  state.staircase.rotationDirection = direction;
  document.querySelectorAll('.direction-btn.rotation').forEach(btn => btn.classList.remove('active'));
  event.target.closest('.direction-btn').classList.add('active');
  controls.updateView();
}

function nextStep() {
  const { totalHeight } = state.staircase;
  state.staircase.currentStep = (state.staircase.currentStep + 1) % totalHeight;
  controls.updateView();
  if (state.builderMode) updateBuilderDisplay();
}

function prevStep() {
  const { totalHeight } = state.staircase;
  state.staircase.currentStep--;
  if (state.staircase.currentStep < 0) state.staircase.currentStep = totalHeight - 1;
  controls.updateView();
  if (state.builderMode) updateBuilderDisplay();
}

function toggleSingleStep() {
  state.staircase.showSingleStep = !state.staircase.showSingleStep;
  const button = document.getElementById('single-step-toggle');
  const stepNav = document.getElementById('step-nav-buttons');
  
  if (state.staircase.showSingleStep) {
    button.classList.add('active');
    button.querySelector('.material-icons').textContent = 'filter_1';
    button.title = 'Showing single step';
    stepNav.style.display = 'flex';
  } else {
    button.classList.remove('active');
    button.querySelector('.material-icons').textContent = 'view_carousel';
    button.title = 'Show single step';
    stepNav.style.display = 'none';
  }
  
  controls.updateView();
}

function toggleBuilderMode() {
  state.builderMode = !state.builderMode;
  
  const controlsPanel = document.querySelector('.controls-panel');
  const topBar = document.querySelector('.top-app-bar');
  const builderOverlay = document.getElementById('builder-overlay');
  const builderControls = document.getElementById('builder-controls');
  const builderInfo = document.getElementById('builder-info');
  
  if (state.builderMode) {
    if (state.viewMode === '3d') toggleViewMode();
    
    controlsPanel.style.display = 'none';
    topBar.style.display = 'none';
    builderOverlay.style.display = 'block';
    builderControls.style.display = 'flex';
    builderInfo.style.display = 'block';
    
    updateBuilderDisplay();
    resizeCanvas();
  } else {
    controlsPanel.style.display = 'flex';
    topBar.style.display = 'flex';
    builderOverlay.style.display = 'none';
    builderControls.style.display = 'none';
    builderInfo.style.display = 'none';
    
    resizeCanvas();
  }
}

function updateBuilderDisplay() {
  document.getElementById('builder-step-number').textContent = state.staircase.currentStep + 1;
  document.getElementById('builder-step-total').textContent = state.staircase.totalHeight;
  document.getElementById('builder-height').textContent = `Height: ${state.staircase.totalHeight} blocks`;
  document.getElementById('builder-rotation').textContent = `Rotation: ${state.staircase.rotationDegrees}°`;
  document.getElementById('builder-vertical').textContent = `Vertical: ${state.staircase.verticalDirection === 1 ? 'Up' : 'Down'}`;
  document.getElementById('builder-spiral').textContent = `Spiral: ${state.staircase.rotationDirection === 1 ? 'CCW' : 'CW'}`;
}

function toggleViewMode() {
  state.viewMode = state.viewMode === '2d' ? '3d' : '2d';
  
  const canvas2D = document.getElementById('myCanvas');
  const scene3D = document.getElementById('scene3d');
  const toggleBtn = document.getElementById('view-toggle');
  const viewModeControl = document.getElementById('view-mode-control');
  const stepNav = document.getElementById('step-nav-buttons');
  
  if (state.viewMode === '3d') {
    canvas2D.style.display = 'none';
    scene3D.style.display = 'block';
    toggleBtn.classList.add('active');
    toggleBtn.innerHTML = '<span class="material-icons">grid_view</span> 2D Mode';
    viewModeControl.style.display = 'flex';
    
    if (state.staircase.showSingleStep) {
      stepNav.style.display = 'flex';
    } else {
      stepNav.style.display = 'none';
    }
    
    if (!state.view3D.scene) {
      render3D.init();
    } else {
      render3D.generateStaircase();
      if (state.view3D.renderer) {
        const container = document.getElementById('scene3d');
        const rect = container.getBoundingClientRect();
        state.view3D.renderer.setSize(rect.width, rect.height);
        state.view3D.camera.aspect = rect.width / rect.height;
        state.view3D.camera.updateProjectionMatrix();
        state.view3D.needsRender = true;
      }
    }
  } else {
    canvas2D.style.display = 'block';
    scene3D.style.display = 'none';
    toggleBtn.classList.remove('active');
    toggleBtn.innerHTML = '<span class="material-icons">view_in_ar</span> 3D Mode';
    viewModeControl.style.display = 'none';
    stepNav.style.display = 'flex';
    resizeCanvas();
  }
}

function resizeCanvas() {
  if (state.viewMode === '3d') return;
  
  const d = document.getElementById('canvas-container');
  const elHeight = d.clientHeight;
  const elWidth = d.clientWidth;
  
  let width = elWidth;
  let height = elHeight;
  const { width: ellipseWidth, height: ellipseHeight } = state.ellipse;
  const { scale } = state.canvas;
  
  const h1 = height;
  const w1 = height * ellipseWidth / ellipseHeight;
  const w2 = width;
  const h2 = width * ellipseHeight / ellipseWidth;
  
  if (w1 > w2) {
    width = w2;
    height = h2;
  } else {
    width = w1;
    height = h1;
  }
  
  width *= scale[2];
  height *= scale[3];
  
  const can = document.getElementById('myCanvas');
  state.canvas.width = width;
  state.canvas.height = height;
  can.width = elWidth;
  can.height = elHeight;
  
  const ctx = can.getContext('2d');
  render2D.draw(ctx);
}

function toggleTheme() {
  const currentTheme = document.documentElement.getAttribute('data-theme') || 'dark';
  const newTheme = currentTheme === 'light' ? 'dark' : 'light';
  
  document.documentElement.setAttribute('data-theme', newTheme);
  const themeIcon = document.getElementById('theme-icon');
  if (themeIcon) {
    themeIcon.textContent = newTheme === 'light' ? 'dark_mode' : 'light_mode';
  }
  
  if (state.viewMode === '3d') {
    render3D.updateTheme();
  } else {
    resizeCanvas();
  }
}

window.addEventListener('load', () => {
  document.getElementById('ellw').value = state.ellipse.width;
  document.getElementById('ellh').value = state.ellipse.height;
  document.getElementById('innerellw').value = state.ellipse.innerWidth;
  document.getElementById('innerellh').value = state.ellipse.innerHeight;
  document.getElementById('totalheight').value = state.staircase.totalHeight;
  document.getElementById('rotation').value = state.staircase.rotationDegrees;
  document.getElementById('startangle').value = state.staircase.startingAngle;
  
  controls.updateMirrorButton('outer-mirror', state.ellipse.outerMirrored);
  controls.updateMirrorButton('inner-mirror', state.ellipse.innerMirrored);
  
  document.documentElement.setAttribute('data-theme', 'dark');
  const themeIcon = document.getElementById('theme-icon');
  if (themeIcon) {
    themeIcon.textContent = 'light_mode';
  }
  
  keyHandlers.init();
  
  state.viewMode = '3d';
  render3D.init();
});

window.addEventListener('resize', () => {
  if (state.viewMode === '3d' && state.view3D.renderer) {
    const container = document.getElementById('scene3d');
    const rect = container.getBoundingClientRect();
    state.view3D.renderer.setSize(rect.width, rect.height);
    state.view3D.camera.aspect = rect.width / rect.height;
    state.view3D.camera.updateProjectionMatrix();
    state.view3D.needsRender = true;
  } else if (state.viewMode === '2d') {
    resizeCanvas();
  }
});

window.addEventListener('beforeunload', () => {
  keyHandlers.cleanup();
  if (state.viewMode === '3d') {
    render3D.cleanup();
  }
});
</script>

</head>

<body>
    
<header class="top-app-bar">
    <h1>Ellipse Ring Staircase</h1>
    <div class="header-controls">
        <button class="view-toggle" id="builder-toggle" onclick="toggleBuilderMode()" title="Toggle Builder Mode">
            <span class="material-icons">fullscreen</span> Builder
        </button>
        <button class="view-toggle active" id="view-toggle" onclick="toggleViewMode()" title="Toggle View Mode">
            <span class="material-icons">grid_view</span> 2D Mode
        </button>
        <button class="theme-toggle" onclick="toggleTheme()" title="Toggle theme">
            <span class="material-icons" id="theme-icon">light_mode</span>
        </button>
    </div>
</header>

<div class="content">
    <div class="controls-panel">
        
        <div class="surface">
            <h2>Outer Ellipse</h2>
            <div class="control-group">
                <span class="label">Width</span>
                <button class="btn btn-filled" onclick="controls.adjustValue(controlConfigs.outerWidth, -1)">−</button>
                <input type="text" id="ellw" class="input-field" onblur="controls.getValue(controlConfigs.outerWidth)">
                <button class="btn btn-filled" onclick="controls.adjustValue(controlConfigs.outerWidth, 1)">+</button>
                <button class="btn-icon" id="outer-mirror" onclick="toggleOuterMirror()">
                    <span class="material-icons">sync</span>
                </button>
            </div>
            <div class="control-group">
                <span class="label">Height</span>
                <button class="btn btn-filled" onclick="controls.adjustValue(controlConfigs.outerHeight, -1)">−</button>
                <input type="text" id="ellh" class="input-field" onblur="controls.getValue(controlConfigs.outerHeight)">
                <button class="btn btn-filled" onclick="controls.adjustValue(controlConfigs.outerHeight, 1)">+</button>
            </div>
        </div>

        <div class="surface">
            <h2>Inner Ellipse</h2>
            <div class="control-group">
                <span class="label">Width</span>
                <button class="btn btn-filled" onclick="controls.adjustValue(controlConfigs.innerWidth, -1)">−</button>
                <input type="text" id="innerellw" class="input-field" onblur="controls.getValue(controlConfigs.innerWidth)">
                <button class="btn btn-filled" onclick="controls.adjustValue(controlConfigs.innerWidth, 1)">+</button>
                <button class="btn-icon" id="inner-mirror" onclick="toggleInnerMirror()">
                    <span class="material-icons">sync</span>
                </button>
            </div>
            <div class="control-group">
                <span class="label">Height</span>
                <button class="btn btn-filled" onclick="controls.adjustValue(controlConfigs.innerHeight, -1)">−</button>
                <input type="text" id="innerellh" class="input-field" onblur="controls.getValue(controlConfigs.innerHeight)">
                <button class="btn btn-filled" onclick="controls.adjustValue(controlConfigs.innerHeight, 1)">+</button>
            </div>
        </div>

        <div class="surface">
            <h2>Staircase</h2>
            
            <div class="control-group" id="view-mode-control">
                <span class="label">View Mode</span>
                <button class="btn-icon" id="single-step-toggle" onclick="toggleSingleStep()" title="Show single step">
                    <span class="material-icons">view_carousel</span>
                </button>
            </div>
            
            <div class="control-group" id="step-nav-buttons" style="display: none; flex-direction: column; gap: 8px; width: 100%;">
                <div style="display: flex; gap: 8px;">
                    <button class="btn btn-filled" onclick="prevStep()" style="flex: 1;">
                        <span class="material-icons">chevron_left</span>
                    </button>
                    <button class="btn btn-filled" onclick="nextStep()" style="flex: 1;">
                        <span class="material-icons">chevron_right</span>
                    </button>
                </div>
            </div>
            
            <div class="control-group">
                <span class="label">Total Height</span>
                <button class="btn btn-filled" onclick="controls.adjustValue(controlConfigs.totalHeight, -1)">−</button>
                <input type="text" id="totalheight" class="input-field" onblur="controls.getValue(controlConfigs.totalHeight)">
                <button class="btn btn-filled" onclick="controls.adjustValue(controlConfigs.totalHeight, 1)">+</button>
            </div>
            
            <div class="control-group">
                <span class="label">Rotation (°)</span>
                <button class="btn btn-filled" onclick="controls.adjustValue(controlConfigs.rotation, -45)">−</button>
                <input type="text" id="rotation" class="input-field" onblur="controls.getValue(controlConfigs.rotation)">
                <button class="btn btn-filled" onclick="controls.adjustValue(controlConfigs.rotation, 45)">+</button>
            </div>
            
            <div class="control-group">
                <span class="label">Start Angle (°)</span>
                <button class="btn btn-filled" onclick="controls.adjustValue(controlConfigs.startAngle, -45)">−</button>
                <input type="text" id="startangle" class="input-field" onblur="controls.getValue(controlConfigs.startAngle)">
                <button class="btn btn-filled" onclick="controls.adjustValue(controlConfigs.startAngle, 45)">+</button>
            </div>
            
            <div class="control-group">
                <span class="label">Vertical</span>
                <div class="direction-toggle">
                    <button class="direction-btn vertical active" onclick="setVerticalDirection(1)">
                        <span class="material-icons">arrow_upward</span>
                        Up
                    </button>
                    <button class="direction-btn vertical" onclick="setVerticalDirection(-1)">
                        <span class="material-icons">arrow_downward</span>
                        Down
                    </button>
                </div>
            </div>
            
            <div class="control-group">
                <span class="label">Spiral</span>
                <div class="direction-toggle">
                    <button class="direction-btn rotation active" onclick="setRotationDirection(1)">
                        <span class="material-icons">rotate_left</span>
                        CCW
                    </button>
                    <button class="direction-btn rotation" onclick="setRotationDirection(-1)">
                        <span class="material-icons">rotate_right</span>
                        CW
                    </button>
                </div>
            </div>
        </div>

        <div class="instructions">
            <div class="instruction-row">
                <span class="material-icons">view_in_ar</span>
                <span>Drag to rotate view</span>
            </div>
            <div class="instruction-row">
                <span class="material-icons">open_with</span>
                <span>Shift+drag to pan camera</span>
            </div>
            <div class="instruction-row">
                <span class="material-icons">zoom_in</span>
                <span>Mouse wheel to zoom</span>
            </div>
            <div class="instruction-row">
                <span class="material-icons">keyboard</span>
                <span>WASD/Arrows to move, Q/E for up/down</span>
            </div>
        </div>

        <div class="surface" style="font-size: 12px; padding: 12px;">
            <div style="color: var(--on-surface-variant); line-height: 1.4;">
                <div style="margin-bottom: 8px;">
                    <strong>Inspired by:</strong><br>
                    Timothy Miller, Binghamton University
                </div>
                <div>
                    <a href="https://www.cs.binghamton.edu/~millerti/circlegen.html" 
                       target="_blank" 
                       style="color: var(--primary); text-decoration: none;"
                       onmouseover="this.style.textDecoration='underline'"
                       onmouseout="this.style.textDecoration='none'">
                        View Original →
                    </a>
                </div>
            </div>
        </div>

    </div>

    <div class="canvas-container" id="canvas-container">
        <canvas id="myCanvas" style="display: none;"></canvas>
        <div id="scene3d"></div>
        
        <div class="builder-overlay" id="builder-overlay" style="display: none;">
            <h2>Step <span id="builder-step-number">1</span></h2>
            <p>of <span id="builder-step-total">20</span></p>
        </div>
        
        <div class="builder-controls" id="builder-controls" style="display: none;">
            <button class="btn btn-filled" onclick="prevStep()">
                <span class="material-icons">chevron_left</span>
                Previous
            </button>
            <button class="btn btn-filled" onclick="toggleBuilderMode()">
                <span class="material-icons">close</span>
                Exit
            </button>
            <button class="btn btn-filled" onclick="nextStep()">
                Next
                <span class="material-icons">chevron_right</span>
            </button>
        </div>
        
        <div class="builder-info" id="builder-info" style="display: none;">
            <div id="builder-height">Height: 20 blocks</div>
            <div id="builder-rotation">Rotation: 360°</div>
            <div id="builder-vertical">Vertical: Up</div>
            <div id="builder-spiral">Spiral: CCW</div>
            <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid var(--outline-variant);">
                <strong>Controls:</strong><br>
                ← → Arrow keys<br>
                ESC to exit
            </div>
        </div>
    </div>
</div>

</body>
</html>